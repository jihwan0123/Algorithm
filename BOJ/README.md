# 2021

## <03.06>

### 2447. [별찍기 -10](./silver1/boj_2447.py)

- 머리로는 공백을 찍거나 별을 찍는게 생각이 되는데 구현이 되지 않았다.

- 1 2 3

- 4 5 6

- 7 8 9

- 위와 같이 3*3이 있을때, 5번만 공백이고 나머지는 *

- 이러한 구조를 하나로 봐서 1 ~ 9 까지 들어가는 식으로 반복된다.

-  별을 채워놓은 상태에서 공백을 찍고싶었는데 생각대로 되지 않아서 하나씩 돌면서 별을 찍는 방식으로 코드를 작성하였다.

  - 전체를 다 돌면서 별을 찍어서 시간이 오래걸리는것 같다.



- 💡 다음과 같이 zip 과 join 을 이용하면 간단하게 구현할 수 있다.

  - 파이썬의 장점을 이용하자!

  ```python
  def concatenate(r1, r2):
      return [''.join(x) for x in zip(r1, r2, r1)]
  ```

  



### 7562. [나이트의 이동](./silver2/boj_7562.py)

- BFS를 구현하는 방법에 대해 복습할 수 있었다.
- 시간을 줄이는 방법에 대해 더 생각해봐야 할듯하다.



## <03.27>

### 11399. [ATM](./silver3/boj_11399.py)

- 오름차순으로 정렬 후 더하기



### 16953. [A -> B](./silver1/boj_16953.py)

- queue 이용
- queue에 현재 정수(n)과 횟수(cnt)를 저장
- 두 가지 연산을 했을때 b보다 작거나 같을때만 queue에 저장하면서 반복
- b랑 같으면 종료 후 ans에 실행 횟수(cnt) 저장, 같지 않으면 ans의 초기값인  -1



## <03.28>

### 12907. [동물원](./gold5/boj_12907.py)

- 0부터 오름차순으로 순서대로 존재해야한다.
- 리스트에 저장했을 때, 1 또는 2여야 하고 3이면 존재하지 않으므로 res = 0
- 1이 나왔으면, 그 뒤에는 1보다 큰 수가 나올 수가 없다.
  - 1이 나오고 0이 나왔다면, 0보다 큰 수 또한 나올 수가 없다.
- 처음에는 dict를 이용하여 풀려고 했지만, 구현하는 것이 복잡해서 list로 변경

## <03.29>

### 16922. [로마 숫자 만들기](./silver3/boj_16922.py)

- BFS이용해서 풀이
- N번째에 set에 add해서 길이를 구했는데 처음에 시간초과가 발생했다.
- dfs안에 for문을 2개 사용했는데, 필요없는 for문이어서 제거했고, 더한 값도 바로바로 더하면서 dfs를 진행하여 시간초과를 해결하였다.

### 12871. [무한 문자열](./silver5/boj_12871.py)

- s, t에 각 문자열의 길이를 곱해서 같은 길이에서 같은지 비교했다.
- 길이가 매우 커지면 최소공배수까지만 만들어서 비교하는게 더 좋을것 같다.

### 12904. [A 와 B](./gold5/boj_12904.py)

- 처음엔 A -> B(16953)번처럼 풀었지만 시간초과 발생
- 작은거부터 시작해서 경우의 수가 너무 많기때문
- 큰거부터 시작해서 거꾸로 돌아가면서 같아지는지 확인했다.

## <03.31>

### 1242. [소풍](./gold2/boj_1242.py)

- 시작하는 위치 중심으로 k번째가
  - 동호의 번호와 같으면 종료
  - 작으면 동호의 번호 하나 감소
  - 한바퀴 돌면 끝나는 지점 = 시작지점으로 설정 후 끝날때까지  반복

### 17103. [골드바흐 파티션](./silver2/boj_17103.py)

- 에라토스테네스의 체 이용
- 소수 반복하면서 입력 값에서 소수 빼고 남은 수가 소수이면 ans + 1

## <04.03>

### 16973. [직사각형 탈출](./gold5/boj_16973.py)

- BFS사용
- 시간초과 발생 (나중에 다시 풀기)

## <04.09>

### 2178. [미로 탐색](./silver1/boj_2178.py)

- BFS

### 2206. [벽 부수고 이동하기](./gold4/boj_2206.py)

- DFS(recursion error)
- BFS
  - visited를 1차원으로 사용했을 경우
    - test_case는 통과했지만 오답
    - 앞에서 벽을 뚫고 왔을때와 뚫지 않고 왔을 때 거리가 같은 경우 문제가 발생한다.
      - 뚫었을 경우와 뚫지 않은 경우를 나눠서 2차원 배열생성해서 방문체크

## <04.10>

### 1697. [숨바꼭질](./silver1/boj_1697.py)

- BFS
- x-1, x+1, x*2 를 queue에 저장하면서 가는데 걸린 시간 visited에 체크 , 동생 찾으면 return
- queue를 만들 때 list 대신 deque를 생성하면 속도가 훨씬 빨라진다 (`from collections import deque`)
  - 시간복잡도 O(n) vs O(1) 차이

## 11866. [요세푸스0](./silver4/boj_11866.py)

- deque.rotate 사용해봄



## <04.24>

### 1753. [최단경로](./gold5/boj_1753.py)

- dijkstra
- 인접 행렬 사용하면 메모리초과 (1≤V≤20,000, 1≤E≤300,000)
- 시간초과 발생
  - 우선순위 큐 + sys.stdin.readline 사용하니 통과

## <04.25>

### 1920. [수 찾기](./silver4/boj_1920.py)

- 이진탐색 연습

### 1197. [최소 스패닝 트리](./gold4/boj_1197.py)

- MST 연습 (prim, kruskal)
- prim은 heapq 안쓰니까 시간초과 발생(최솟값 계속 구해서 그런듯?)



## <06.03>

### 1916. [최소비용 구하기](./gold5/boj_1916.py)

- 다익스트라 연습
- heapq 사용, input=sys.stdin.readline 안하면 시간초과
- 인접리스트 만들때 도시의 개수로 만들어야되는데 버스의 개수로 만들어서 계속 indexerror 발생



## <06.11>

### 2629. [양팔저울](./gold2/boj_2629.py)

> https://www.acmicpc.net/problem/2629

- DP문제
- `memo[level][weight]`
  - level 개를 사용했을때 weight 무게가 있는지 체크
- 확인하고자 하는 무게가 40000이하이므로, memo 범위 40001까지 설정
- +, 그대로, - 3가지 branch 진행하면서 memo
- 메모했거나 전부 사용했으면 return

## <06.22>

### 9663. [nQueen](./gold5/boj_9663.py)

### 1260. [DFS와 BFS](./silver2/boj_1260.py)

- 둘 다 PyPy3으로 제출하면 통과, Python3으로 하면 시간 초과

## <06.24>

### 2667. [단지번호붙이기](./silver1/boj_2667.py)

- dfs

## <06.28>

### 2637. [장난감조립](./gold2/boj_2637.py)

> https://www.acmicpc.net/problem/2637

- 위상정렬
- 진입 차수가 0인거부터 시작
- 연결된 부분들 계산하면서 간선 제거
- 차수가 0이 되면 큐에 추가해서 반복

## <07.03>

### 11659. [구간합구하기4](./silver3/boj_11659.py)

## <07.06>

### 14466. [소가 길을 건너간 이유 6](./gold4/boj_14466.py)

> https://www.acmicpc.net/problem/14466

## <07.07>

### 3273. [두 수의 합](./silver3/boj_3273.py)

### 2003. [수들의 합2](./silver3/boj_2003.py)

- 투 포인터 사용

## <07.08>

### 1062. [가르침](./gold4/boj_1062.py)

> https://www.acmicpc.net/problem/1062

> 비트마스킹 사용

>  처음에 60%쯤에서 오답이 나왔다.
>
> ※반례
>
> 2 15
> antabtica
> antatica
>
> ans = 2 나와야 하는데 0이 나왔다. => 전체 단어의 수(len(all_words)보다 k가 크면 n 출력

## <07.09>

### 15686. [치킨 배달](./gold5/boj_15686.py)

>https://www.acmicpc.net/problem/15686

처음에 bfs로 접근해서 시간이 엄청 오래걸렸다.

가정집, 치킨집 좌표를 저장해두고 완전 탐색하며 최소 거리를 계산하면 훨씬 간단해진다.



## <07.10>

### 16234. [인구 이동](./gold5/boj_16234.py)

> PyPy3 으로 pass
>
> 4 1 9
> 96 93 74 30
> 60 90 65 96
> 5 27 17 98
> 10 41 46 20
>
> ans = 1

처음에 방문표시 따로, 인구수 계산 따로 해서 시간초과 발생

visited 표시를 할 때 이동 못하는 부분이 방문처리 되어서 오류 발생

chk = False이면 visited를 0으로 초기화시켜줘서 해결

## <07.12>

### 15591. [MooTube(Silver)](./gold5/boj_15591.py)

- bfs로 연결 가능한 노드 탐색
- 문제의 설명이 복잡해서 처음에 문제 이해하는게 어려웠다.
  - 농부의 질문 Q마다 v노드에서 인접한 가중치가 k이하인 노드들을 탐색하며 더하는 문제

## <07.20>

### 4485. [녹색 옷 입은 애가 젤다지?](./gold4/boj_4485.py)

- 처음에 왼쪽 오른쪽 DP를 이용해서 풀려고 했는데 실패

```markdown
3 7 2 0 1
2 8 0 9 1
1 2 1 8 1
9 8 9 2 0
3 6 5 1 5
예제 2번의 경우 3-2-1-2-1-0-2-0-1-1-1-0-5 = 19로 아래로 갔다가 위로 올라가야 하는 경우가 있다.
```

- 다익스트라 사용
  - heapq로 최소거리부터 탐색, n-1,n-1까지 가면 종료

## <07.21>

### 22251. [빌런호석](./gold5/boj_22251.py)

- 0부터 9까지 각각 0~9로 바꿀때의 변경 횟수 저장
- 1부터 n까지 돌면서 바꿀 수 있는지 비교
- 자리수 비교할 때 1의자리부터 비교해야 편함, 앞에서부터 비교 하려면 0 채워놓고 비교해야함

### 22252. [정보상인호석](./gold5/boj_22252.py)

- dict에 heapq 이용해서 push/pop

- 꺼낼 때 없는이름 for문 돌리고 if info.get(name) 계속 확인해서 시간초과 발생

  name 없는거 바로 continue하고,  들어있는 정보 갯수보다 원하는 갯수가 크면 들어있는 정보만큼만 돌렸더니 패스

## <07.22>

### 20055. [컨베이어 벨트 위의 로봇](./silver1/boj_20055.py)

- 문제를 잘 이해하고 1~4번을 따라하면 된다.
- 처음에 컨베이어 벨트의 내구도를 로봇의 내구도라고 생각해서 힘들었다.

## <07.23>

### 14888. [연산자 끼워넣기](./silver1/boj_14888.py)

## <07.24>

### 14499. [주사위 굴리기](./gold5/boj_14499.py)

- 주사위 굴릴때마다 동/서/남/북 구른 후의 모양 생각해서 1~6번 위치에 해당 위치 값으로 변경
- 주사위 맨 처음에 0으로 초기화 조건을 못봐서 헤맸다. (문제 조건 잘 읽기!)

## <07.25>

### 17144. [미세먼지 안녕!](./gold5/boj_17144.py)

- 미세먼지 확산 -> 공기청정기  순서로 주어진 시뮬레이션대로 구현

## <07.26>

### 1916. [최소비용 구하기](./gold5/boj_1916.py)

- 경로 같은데 비용이 다른 경우도 있을 수 있어서 `d[node] < weight` 인 경우 가지치기필요

### 16973. [직사각형 탈출](./gold5/boj_16973.py)

- 직사각형 x,y 전체 검사하면 시간초과
- 벽 위치들만 미리 저장해놓고 검사

## <07.27>

### 20442. [ㅋㅋ루ㅋㅋ](./gold3/boj_20442.py)

> 투 포인터

- lk[] = R의 왼쪽 K갯수, rk[] = R의 오른쪽 K갯수
- 문자를 지워서 새로운 문자열을 만들 수 있다.
- lk와 rk 중에서 작은 수만큼 K를 붙일 수 있다.
  - 양쪽에 붙일 수 있으므로 2배
  - `2 * min(lk([l], rk[r])`
- lk와 rk의 길이는 R의 갯수이다.
  - 연속된 R은 ㅋㅋ루ㅋㅋ 문자열이 된다.
  - `r - l + 1`

## <07.29>

### 12865. [평범한 배낭](./gold5/boj_12865.py)

> 0/1 *Knapsack* Problem

ABCD의 value와 weight가 있을 때,

A,B,C,D가 있는 경우 vs 없는경우로 나눠서 DP

`DP(n,w) = max(DP(n-1,w), DP(n-1, w-w[n]) + val[n])`

## <07.30>

### 2580. [스도쿠](./gold4/boj_2580.py)

> 빈칸에 들어갈 값들 채워보면서 백트래킹

## <07.31>

### 11003. [최솟값 찾기](./platinum5/boj_11003.py)

> 슬라이딩 윈도우 + deque

Di =  Ai부터 Ai바로 전 L개의 윈도우까지의 최솟값이다.

시간복잡도가 O(1)인 deque를 이용해서 (값, 인덱스) 번호인 (Ai, i)를 저장한다.

윈도우를 이동하면서 인덱스값이 윈도우를 벗어나면 윈도우에서 제거하고, 값이 넣는 값보다 더 크면 윈도우에서 제거한다.

그러면 항상 윈도우에서 최솟값이 제일 앞에 존재한다.

```markdown
윈도우 크기 : 3
1 5 2 3 6 2 3 7 3 5 2 6

(1), (1,5), (1,5,2) (5,2,3), (2,3,6), (3,6,2) ,(6,2,3) ... (5,2,6)의 최솟값이 D이다.
=> 1 1 1 2 2 2 2 2 3 3 2 2

3개씩 하나하나 비교해서 최솟값을 출력하면 시간초과 발생한다. => 슬라이딩 윈도우
가운데 겹치는 L-1개는 그대로 두고 앞에서 하나 제거, 뒤에서 하나 추가 => deque

윈도우가 커지면 윈도우 안에서 최솟값을 출력할 때도 비교해야한다.
=> 윈도우에 넣을 때 넣는 값보다 큰 값을 미리 제거해서 맨 앞의 값을 최솟값으로 만든다.
```

## <08.01>

### 1306. [달려라 홍준](./platinum5/boj_1306.py)

> 슬라이딩 윈도우

위의 최솟값 찾기 문제처럼 윈도우에 최댓값 저장하고 작은값 제거 + 윈도우 벗어나면 제거

광고판을 항상 2m-1개씩 봐야하므로, ans[2m-2:] join해서 출력

## <08.02>

### 21924. [도시 건설](./gold4/boj_21924.py)

> MST - Prim 알고리즘

임의의 점에서 시작해서 연결된 노드들 리스트에 삽입

heapq 최소힙 사용해서 작은 순서대로 정렬

- heapq 없이 최솟값 구했더니 시간초과발생

visited 처리하면서 모든 점을 방문하면 종료

모든 점 방문하지 못하고 while문 끝나면 -1 return

## <08.03>

### 10844. [쉬운 계단 수](./silver1/boj_10844.py)

> DP

0일때와 9일때는 각각 1, 8밖에 올 수 없고 1~8까지는 앞뒤로 2개의 수만큼 올 수 있다. 따라서 다음과 같은 식을 세울 수 있다.

```markdown
dp[i][j] = dp[i-1][j+1] (j=0)
dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1] (0<j<9)
dp[i][j] = dp[i-1][j-1] (j=9)

dp[i][j] => i번째 자리에 j가 올 수 있는 경우의 수
```

한자리수일땐 맨 앞에 0이 올 수 없으므로 `dp[1][0]=0` , 나머지는 1로 초기화한 후 올라가면서 계산하고 n번째 자리에 0~9가 오는 경우의 합을 구한다.

## <08.04>

### 5014. [스타트링크](./gold5/boj_5014.py)

> BFS

DFS로 접근하면 시간초과 발생 => BFS사용

## <08.05>

### 5430. [AC](./gold5/boj_5430.py)

> deque사용해서 뒤집었는지 여부에 따라서 pop / popleft로 앞이나 뒤에거 제거
>
> 계속 오답이 나왔었는데, 전체 리스트를 다 지우면 빈 문자열을 출력해야하고 빈 상태에서 한번 더 지워야 error를 출력하는것이다.

## <08.07>

### 1300. [K번째 수](./gold3/boj_1300.py)

> 이분탐색
>
> 전체 배열을 만들어서 1차원 배열로 옮기면 메모리 초과 발생

x보다  작거나 같은 수의 갯수 = min(x//i, N)

N = 3, x는 4이면

| i=1     | 1     | 2     | 3    | min(4, 3) = 3     |
| ------- | ----- | ----- | ---- | ----------------- |
| **i=2** | **2** | **4** | 6    | **min(2, 3) = 2** |
| **i=3** | **3** | 6     | 9    | **min(1, 3) = 1** |

4보다 작거나 같은 수의 갯수 cnt = 3 + 2 + 1 = 6이다.

cnt >= k가 되면, cnt보다 작거나 같은 수가 k개이므로 B[k]가 될 수 있다.

left = 1, right = k로 두고 시작해서,

k가 cnt보다 크면  더 큰 부분을 탐색해야 하므로 left = mid + 1

작거나 같으면, right = mid -1, ans = mid로 초기화 하면서 left = right가 될 때까지 계속 탐색한다.

```markdown
예제에서 N=3, K=7이므로

i) left = 1, right = 7, mid = 4

cnt = 6 < k이므로 left = 5

ii) left=5, right = 7, mid = 6

cnt = 8 > k 이므로 ans = 6, right = 5

iii) left = right =5 이므로 종료
```

## <08.08>

### 11053. [가장 긴 증가하는 부분수열](./silver2/boj_11053.py)

> 전체 수열 돌면서 앞의 값과 비교해서 dp 저장

### 12015. [가장 긴 증가하는 부분수열2](./gold2/boj_12015.py)

> bisect 이진탐색 사용
>
> bisect_left(a, x) = a에 x를 삽입할 인덱스 왼쪽값 리턴

```markdown
10 20 10 30 20 50
```

0. 초기값 [10] 넣어두고 시작

1. 20 입력 =>  [10 20], 10보다 크므로 끝에 20 추가
2. 10 입력 => [10 20] , 20보다 작으므로 10을 넣을 위치 탐색, ans[0] = min(10,10)값으로 변경
3. 30 입력 =>  [10 20 30], 20보다 크므로 끝에 30추가 
4. 20 입력 => [10 20 30], 30보다 작으므로 20넣을위치 탐색, ans[1]=min(20,20)으로 변경
5. 50 입력 => [10 20 30 50], 30보다 크므로 맨 끝에 삽입
6. len(ans) =  4

### 12738. [가장 긴 증가하는 부분수열3](./gold2/boj_12738.py)

> 2와 숫자의 범위만 바뀌었다. 코드는 동일

### 14002. [가장 긴 증가하는 부분수열4](./gold4/boj_14002.py)

> 11053번 DP 사용해서 구한 ans에서 거꾸로 내려오면서 저장

## <08.10>

### 2573. [빙산](./gold4/boj_2573.py)

> 빙산 있는 좌표 저장해서 시뮬레이션 실행 이후 BFS 사용해서 빙산 덩어리 체크

**만일 전부 다 녹을 때까지 두 덩어리 이상으로 분리되지 않으면 프로그램은 0을 출력한다.**

- 처음에 조건 하나 체크 못해서 56퍼에서 오답
- 전부 길이 체크해서 전부 0이면 0출력하고 바로 종료

## <08.12>

### 2661. [좋은 수열](./gold4/boj_2661.py)

> dfs로 돌면서 전부 확인

## <08.15>

### 1644. [소수의 연속합](./gold3/boj_1644.py)

> 에라토스테네스의 체 + 맨 처음부터 start, end 잡고 한칸씩 이동하면서 연속합이 되는지 체크

### 1747. [소수 & 팰린드롬](./gold5/boj_1747.py)

> 입력이 1 ~ 1000000 이지만 출력은 1000000보다 클 수 있다
>
> 1000000일때 1003001이 나오므로 MAX_SIZE = 1003001로 잡고 에라토스테네스의 체를 구한다.

## <08.16>

### 14891. [톱니바퀴](./gold5/boj_14891.py)

> deque.rotate 사용
>
> 하나씩 돌면서 시계/반시계 확인하는 줄 알았는데 초기위치로 비교해서 도는 방식이었다.

## <08.18>

### 2606. [바이러스](./silver3/boj_2606.py)

> 단순 BFS

## <08.19>

### 9205. [맥주 마시면서 걸어가기](./silver1/boj_9205.py)

> BFS
>
> 방문한 좌표를 dict에 저장해서 방문했는지 체크해서 목적지까지 이동할 수 있는지 체크

## <08.20>

### 2644. [촌수계산](./silver2/boj_2644.py)

> BFS

## <08.21>

### 2468. [안전 영역](./silver1/boj_2468.py)

> BFS + 완전탐색

## <08.22>

### 7569. [토마토](./silver1/boj_7569.py)

> BFS + deque 사용

익은 토마토 좌표를 저장해놓고 deque에서 꺼내면서 상하좌우앞뒤 6방향의 토마토를 1로 만들고 deque에 저장하면서 인접한 칸을 바꿀 수 없을때까지 진행

최종적으로 안익은 토마토(0)가 있는지 체크해서 있으면 -1, 없으면 ans

## <08.30>

### 13458. [시험감독](./bronze/boj_13458.py)

- 단순 계산

## <08.31>

### 3190. [뱀](./gold5/boj_3190.py)

- deque를 이용해서 규칙대로 사과 유무에 따라 이동, 제거 (꼬리 위치 저장용도)
- visited로 현재 뱀 위치 표시
- 벽에 부딪히거나, 몸에 부딪히면 종료
- **모든 방향 명령이 끝난 이후에는 벽이나 몸에 부딪힐때까지 마지막 방향으로 계속 이동한다.**

## <09.01>

### 14501. [퇴사](./silver4/boj_14501.py)

- 범위가 작아서 bfs로 계산하면 금방 풀린다.
- dp로도 풀이
  - `T_i`일 이후와 하루 뒤의 dp를 갱신하면서 계산
  - index error때문에 n번째 넘어가지 않게 조건을 걸거나 dp 배열을 크게 잡아야 한다. 
    - 여기서는 i + P_i <= n 조건을 걸어서 제한했다.

## <09.02>

### 1966. [프린터큐](./silver3/boj_1966.py)

- deque 이용

## <09.05>

### 20500. [Ezreal 여눈부터 가네 ㅈㅈ](./gold5/boj_20500.py)

- dfs로 하면 recursion error발생 (dp로 풀어야한다.)

- 15의 배수 = 3의배수 + 5의배수

  - `dp[i][j] `= i번째 자리일 때 j라는 나머지를 가진 수

- 5의 배수

  - `dp[1][1] = 1`

- 3의 배수

  - 모든 자리수의 합이 3으로 나눠지면 3의 배수

  - 1더하면 1%3 = 1 증가, 5더하면 5%3 = 2 증가

  - `dp[i][0] = dp[i-1][1] + dp[i-1][2]`

    `  dp[i][1] = dp[i-1][0] + dp[i-1][2]`

    `  dp[i][2] = dp[i-1][0] + dp[i-1][1]`

- `dp[n][0]` = n번째까지 놨을때 15로 나눠지는 수의 개수

## <09.11>

### 19951. [태상이의 훈련소 생활](./silver1/boj_19951.py)

- 누적합
- a부터 b까지 k를 더해서 작업해야 하는 높이를 저장해놓는다.
- b+1은 k를 빼준 이후 높이의 누적합을 계산해서 한번씩만 연산한다.
  - b+1에서 빼주면, a~b 까지는 k만큼 더해지고, b+1번째 부터는 다시 k를 빼주므로 누적합으로 작업해야 하는 높이의 계산이 가능해진다.

## <09.12>

### 11728. [배열 합치기](./silver5/boj_11728.py)

### 1965. [상자넣기](./silver2/boj_1965.py)

- DP

### 2138. [전구와 스위치](./silver2/boj_2138.py)

- 첫번째 스위치를 누르는 경우와 안누르는 경우 나눠서 생각
- 1번 스위치부터 n번 스위치까지 바로 앞 스위치의 값이 원하는 값이랑 같은지 확인 후 다르면 스위치를 누른다.
- 맨 앞의 전구부터 모두 확인했으므로 마지막까지 했을때 다르면 불가능한 경우이므로 -1을 출력한다.

## <09.14>

#### 12782. [비트 우정지수](./silver5/boj_12782.py)

- 자리별로 비교하면서 다르면서 1인 경우, 0인 경우 중 더 큰 값 계산

## <09.15>

#### 17069. [파이프 옮기기2](./gold5/boj_17069.py)

- DP를 파이프가 가로일때, 세로일때, 대각선일때 나눠서 생각
- 벽이 있는 경우 예외처리

## <09.16>

#### 16208. [귀찮음](./silver5/boj_16208.py)

- 정렬한 후 앞에서부터 작은거부터 곱하면서 계산하면 최솟값

## <09.17>

#### 16236. [아기 상어](./gold4/boj_16236.py)

- BFS를 이용한 시뮬레이션 문제
- 처음엔 bfs를 할 때, 먹을 수 있는 물고기가 없고, 크기가 같은 물고기가 있을때의 값을 반환해줘서 무한루프에 걸려 시간초과 오류가 발생했다.
- bfs를 하면 인접한 칸만 체크하므로
  - 먹을 수 있는게 있는지만 확인해서 있으면 가장 위, 가장 왼쪽 순서로 정렬을 통해 첫째 값을 반환하고,
  - eatable이 없으면 반복문을 종료하면 된다.
- 자기 몸집 크기만큼 먹으면 크기를 +1 해가면서 먹을 물고기가 없을때까지 반복

## <09.18>

#### 1937. [욕심쟁이 판다](./gold3/boj_1937.py)

> DFS + DP

- dfs 돌면서 dp를 저장하고 dfs 도중 저장된 값이 있으면 저장된 값 사용
- 전체 탐색하면서 최댓값 갱신 후 출력
  - dxy 순서에 따라 recurssion error가 발생했다.

#### 9375. [패션왕 신해빈](./silver3/boj_9375.py)

- dict로 의상 분류해서 갯수 체크
- 전체 경우의 수 계산 후 아무것도 안입는경우 -1

## <09.19>

#### 1931. [회의실 배정](./silver2/boj_1931.py)

- 끝나는 시간, 시작 시간 순서로 정렬
- n개를 돌면서 현재값을 끝나는 시간으로 갱신하면서 현재 시간보다 시작 시간이 크거나 같으면 cnt + 1 해서 갯수를 센다.
- sys.stdin.readline 없으면 5000ms, 사용하면 400ms로 크게 줄어들었다.

## <09.20>

#### 17129. [윌리암슨수액빨이딱따구리가 정보섬에 올라온 이유](./gold5/boj_17129.py)

- 단순 BFS문제

#### 5347. [LCM](./silver4/boj_5347.py)

- 유클리드 호제법 : GCD(A, B) = GCD(B, A%B)

- 최소공배수 = 두 수를 곱한 값을 최대공약수로 나눈다.

## <09.21>

#### 17141. [연구소 2](./gold5/boj_17141.py)

- 바이러스가 가능한 위치를 모두 저장한 다음 combination으로 m개를 뽑은 후 BFS
- 결과 중 최솟값 출력
- 아래와 같이 모두 1로 둘러싸여 있어서 바이러스가 퍼지지 못할 경우 0이 나와야 되는데 -1로 처리되서 오답이었다.

```
5 2
1 1 1 1 1
1 1 2 1 1
1 1 2 1 1
1 1 1 1 1
1 1 1 1 1
// 0
```

## <09.22>

#### 20159. [동작 그만, 밑장 빼기냐?](./gold5/boj_20159.py)

- 홀수번, 짝수번 부분합 계산
- 밑장 빼는 경우
  - 내 차례에 빼는경우 : 마지막 카드가 내꺼
  - 상대 차례에 빼는 경우 : 마지막 카드가 상대꺼
- 처음에 상대 차례에 빼는 경우를 생각하지 않아서 계속 오답이었다.

## <09.23>

#### 17484. [진우의 달 여행(Small)](./silver4/boj_17484.py)

- DFS

## <09.24>

#### 1780. [종이의 개수](./silver2/boj_1780.py)

- 모두 같은 종이가 아니면 재귀로 9분할 반복하면서 개수 체크

## <09.25>

#### 17265. [나의 인생에는 수학과 함께](./gold5/boj_17265.py)

- DFS
- 홀수,짝수번째 나눠서 문자열 더하거나, eval 사용해서 계산
- n-1, n-1에서 최대, 최소값 계산

## <09.26>

#### 2252. [줄 세우기](./gold2/boj_2252.py)

- 위상정렬

## <09.27>

#### 1516. [게임 개발](./gold3/boj_1516.py)

- 위상정렬
- 앞선 건물이 모두 지어진 후에 해당 건물을 지을 수 있다.
  - 앞선 건물 중 큰 값이 끝난 후에 해당 건물을 지을 수 있으므로 다음과 같은 식이 나온다.
  - `result[b] = max(result[b], result[now] + cost[b])`

#### 12100. [2048 (Easy)](./gold2/boj_12100.py)

- 시뮬레이션인데 생각해야 되는 것들이 많았다.
- 이동 횟수가 5번밖에 안되서 product를 사용해서 전체 조합 (0,0,0,0,0) ~ (3,3,3,3,3) 까지 만들고 완전탐색했다.
  - 여기서 가지치기하면 시간 줄일 수 있을 것같다.
- 스택 이용해서 같은 숫자 만나면 pop 해서 2배한 후 스택에 추가
- 숫자면 스택에 담고, 0이면 continue
- 이후 차례대로 넣어서 이동 완료
- 한 번 이동한 블록은 합쳐지면 안되도록 True / False 체크
- 한 번도 이동하지 못하는 경우에도 최댓값 계산해야 하므로, 모든 이동이 끝난 후 최댓값 계산 후 출력

## <09.28>

#### 2638. [치즈](./gold4/boj_2638.py)

- (0,0) 부터 bfs 돌면서 0인칸 -1로 변경, 공기와 인접한 치즈칸은 +1
- 치즈가 3이 될 때, 지울 칸에 저장
- 지울 칸 -1로 변경하면서 bfs 반복 후 전체 시간 체크

## <09.29>

#### 17396. [백도어](./gold5/boj_17396.py)

- 다익스트라

- 마지막 넥서스를 0으로 초기화
- 와드가 있는 곳은 그래프에 저장하지 않는다

## <09.30>

#### 4256. [트리](./gold4/boj_4256.py)

- preorder의 맨 앞의 값은 루트노드
- inorder에서 preorder의 값과 일치하는 부분에서 좌, 우로 나눠지는게 반복된다.
- 왼쪽, 오른쪽 순서로 dfs를 하면 마지막에 남는 값부터 출력하면 postorder

## <10.01>

#### 11049. [행렬 곱셈 순서](./gold3/boj_11049.py)

> DP문제

- n * n 행렬을 만들어서 start, end 까지의 곱의 최솟값을 저장한다.

- 2개씩 곱한것부터 n개씩 곱한것 순서로 계산해야 한다.
- start 부터 end까지 곱했을때 최솟값 = (start ~ k 번까지의 연산 수 + k+1부터 end까지의 연산 수 +첫번째 수 * k번째수 * 마지막수)
  - `dp[start][k] + dp[k+1][end] + arr[start][0] * arr[k][1] * arr[end][1]`

- index를 생각하는게 어려웠는데 다른 코드를 참고해서 3중 for문을 이용해서 구현했다.

## <10.02>

#### 2293. [동전 1](./silver1/boj_2293.py)

> DP

- coin을 작은것 부터 차례대로 넣을 수 있는 경우를 계산해준다.
  - coin과 같으면 1개 만들 수 있다.
    - `dp[coin] += 1`
  - 다르면, (i - coin)을 만들고 coin을 추가하는 횟수와 같다.
    - `dp[i] += dp[i-coin]`
- coin 입력이 작은것 부터 들어오지 않아서 sort를 해줘야 한다.
  - sort 없이 제출했더니 50%에서 오답이었다.

#### 14503. [로봇 청소기](./gold5/boj_14503.py)

- BFS
- 4방향에 1로 쌓여 있어서 index 체크 할 필요 없다.
- 조건대로 구현한 후에 청소한 칸 체크해서 출력하면 된다.

## <10.03>

#### 2294. [동전 2](./silver1/boj_2294.py)

> DP

- 동전 1과 비슷한 유형의 문제인데, k원을 만들 수 있는 동전의 최소 개수를 구하는 문제이다.
- dp를 처음에 최댓값으로 초기화 해준다. (동전 최대 가치가 100000이므로 100001로 설정)
- coin과 같은 가격이면 1개로 만들 수 있으므로 `dp[coin] = 1`
- coin + 1 부터 k + 1 까지 확인하면서 `dp[i] = min(dp[i], dp[i-coin] + 1)` 으로 갱신해준다.
  - 1 : i에 coin을 하나 추가
  - `dp[i-coin]` 앞에 저장된 i - coin 만드는데 사용된 값
    - coin만큼 추가했으므로 남은 금액은 (i - coin)
- 처음에 `min(dp[i] = min(dp[i], dp[i % coin] + i//coin))` 과 같이 coin 큰것 부터 넣으려고 했는데 28%에서 오답이 나왔다.
  - 큰걸 먼저 다 넣는다고 항상 최솟값을 보장하지는 않는다.

#### 1535. [안녕](./silver2/boj_1535.py)

> 배낭문제

- [12865. 평범한 배낭](#<07.29>)과 같은 문제
  - 배낭에 넣는다 = 인사를 한다
  - 배낭 최대 크기 = Life
  - 무게 = 기쁨

## <10.04>

#### 10971. [외판원 순회2](./silver2/boj_10971.py)

> DFS

- 일반적인 DFS에 마지막에 시작 위치로 돌아올 수 있는지 체크하면 된다.

#### 1091. [카드 섞기](./gold5/boj_1091.py)

- 핵심 내용
  - 플레이어는 **3명**으로 정해져 있다.
  - **처음 카드는 0, 1, 2, 3, ... n 까지 순서대로 정렬되어 있다.**
    - 이 부분의 설명이 부실한 것 같다.
  - S 는 셔플 규칙을 위한 리스트로 `cards[s[i]] = cards[i]`와 같은 규칙이다.
  - 셔플을 하면서 이전 값과 같은 값이 나오면 무한루프를 도는데, 맨 처음 리스트와 비교하면 된다. 
    - 바로 전의 값과만 비교해서 계속 시간초과가 발생했다.

#### 1003. [피보나치 함수](./silver3/boj_1003.py)

- DP
- 2차원 배열로 0일때, 1일때를 저장한다.
- `fib[0][0] = 1, fib[1][1] = 1` 로 시작
- 피보나치는 앞의 두 수를 더한만큼 호출되므로 다음과 같은 점화식 가능
  - `  fib[0][i] = fib[0][i-1] + fib[0][i-2]`
  - `  fib[1][i] = fib[1][i-1] + fib[1][i-2]`

#### 10451. [순열 사이클](./silver2/boj_10451.cpp)

- c++ 연습
- dfs로 방문 처리하면서 dfs 시작할 수 있는 곳 체크
- 다음 줄 추가해주면 in/out 빨라짐 => [관련내용](https://jaimemin.tistory.com/1521)
- 개행할 때 <<endl 보다 <<'\n' 이 더 빠름

```c++
int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);
}
```

#### 11724. [연결 요소의 개수](./silver2/boj_11724.cpp)

- c++연습

- DFS, BFS

- BFS의 경우 인접한 노드만 확인하지 않으면 1000번을 계속 확인하기 때문에 시간초과 발생

  - 따라서 벡터 사용해서 인접한 노드만 저장

- `vector<int> adj[1001];`

  - `[[],[], [], [], [] ... []]` 
    - python의 `adj = [[] for _ in range(1001)]` 과 같다.
  - `adj[i].push_back[j]` 으로 adj[i]에 j 추가 가능
    - python의 `adj[i].append(j)`과 같다.

- 간선이 0개거나 최댓값인 경우는 간선 연결상태 볼 필요 없이 0과 1이 된다.

- 10451번과 마찬가지로 bfs, dfs 시작한 횟수 출력

## <10.05>

#### 14889. [스타트와 링크](./silver3/boj_14889.cpp)

- c++
- n명중에 2/n명을 뽑은 다음 각 팀의 점수를 계산해서 최솟값을 갱신한다.
- 처음에 모든 `arr[i][j]`의 합을 저장해놓고 한 팀의 점수만 계산 후 빼려고 했는데, 이렇게 하면 1,2 // 3,4 가 팀이라면, 1,3 / 1,4 와 같은 필요없는 값들까지 들어있기 때문에 제대로 된 값 계산이 불가능

## <10.07>

#### 1817. [짐 챙기는 숌](./silver4/boj_1817.py)

- 입력 들어온 순서대로 넣어주는 문제
- 문제를 제대로 이해못해서 무거운 순서부터 넣어서 계속 틀렸다.

## <10.08>

#### 2812. [크게 만들기](./gold5/boj_2812.py)

- 가장 큰 값이 되려면 맨 앞의 자리수가 커야한다.
- stack에 저장하면서 num의 맨 앞에 있는 값이 stack의 마지막 값보다 더 커질 수 있는지 체크하고 더 크면 pop을 반복한다.
- pop해서 제거한 횟수를 체크해서 k개 이상으로 지우는 경우 방지
- 스택에 n-k개 넣기 전에 종료될 수 있으므로 while문이 끝난 이후 stack과 num을 더해서 출력해준다.

## <10.09>

#### 9251. [LCS](./gold5/boj_9251.py)

- DP
  - `dp[i][j] = a[i]까지랑 b[j]까지의 최대 길이`
- `dp[i+1][j+1]`
  - 같으면 `dp[i + 1][j + 1] = dp[i][j] + 1`
    - 같으면 이전까지 최대 공통길이에 1을 더해준다.
  - 다르면 `dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1])`
    - 다르면, a[i+1]까지와 b[j+1]까지의 최대 길이 중 더 큰 값 저장 (이전까지의 최대길이를 저장해야하기 때문)

#### 18110. [solved.ac](./silver4/boj_18110.py)

- 파이썬의 round는 홀수와 짝수일때 반올림이 다르기 때문에 round 새로 정의해서 사용

```python
print(round(2.5)) # 2
print(round(3.5)) # 4
```

- 0일때는 0 출력 (Zero Division 방지)

## <10.10>

#### 20164. [홀수 홀릭 호석](./gold5/boj_20164.py)

- DFS
- 문제에 주어진 대로, 길이가 1, 2, 3이상일때를 나눠서 DFS 진행
- `odd_cnt = sum(map(lambda x: int(x) & 1, sub_num))` 을 이용해서 홀수 갯수 카운트
- 1이면 total에 odd_cnt 더한 후 최대,최소 갱신
- 2나 3이면 조건대로 2등분, 3등분 후 dfs 반복

#### 14502. [연구소](./gold5/boj_14502.cpp)

> C++

- BFS, DFS
- 빈칸 개수와 좌표, 바이러스의 좌표를 처음에 저장해둔다.
- DFS로 바꿀 벽 3개 선택후 BFS
- BFS로 바이러스 퍼지는 칸의 수 체크 후 개수 갱신
  -  `초기 빈칸 개수 - 바이러스 퍼진 칸의 개수 - 3(벽으로 바꾼 칸의 수)` 와 최댓값을 갱신

- C++ 문법
  - `memcpy(arr, arr_origin, sizeof(arr));`
    - `#include <cstring>`
    - arr 배열에 arr_origin을 복사한다.
  - `vector<pair<int, int>> virus_list;`
    - `virus.first, virus.second`로 pair값 사용 가능
  - `queue<pair<int, int>> q;`
    - `q.push(make_pair(nx, ny));`로 q에 값 추가

## <10.11>

#### 21610. [마법사 상어와 비바라기](./gold5/boj_21610.cpp)

> 구현

- 문제에서 주어진 순서대로 구현한다.

- **구름 이동할 때 n을 넘어설 때 index값을 잘 생각해야 한다!**

  - index를 1부터 시작했기 때문에 다음과 같은 작업이 필요했다.

  - ```c++
    if (ny > n) {
        ny = ny % n;
        if (ny == 0) {
            ny = n;
        }
    }
    else if (ny < 1) {
        ny = n - abs(ny % n);
    }
    ```

- C++ 문법
  - `#include<cstring>`
  - `memset(is_removed, false, sizeof(is_removed));` : is_removed 배열을 false로 초기화

## <10.12>

#### 2304. [창고 다각형](./silver2/boj_2304.cpp)

- 지붕 왼쪽, 오른쪽 나눠서 생각한다.
- 왼쪽 끝에서부터 지붕까지 점점 커져야하고, 오른쪽 끝부터 지붕까지 점점 커진다.
- `height[1001]` 선언해놓고, `height[i+1]이 height[i]`보다 작으면 `height[i]`로 바꾸면서 진행
  - 오른쪽 끝에서부터도 마찬가지 `height[j-1], height[j]` 비교

## <10.13>

#### 14719. [빗물](./gold5/boj_14719.cpp)

- 처음에 빗물 최대높이부터 내려오면서 계산했는데, 이런식으로 하면 높이가 바뀌어서 계산하면 안되는 부분까지 계산해버린다.
- 각각의 점마다 좌,우측에서 최댓값을 찾고,
- 그 중에 더 작은값과 현재 높이와의 차이가 고이는 빗물의 양이다.
  - `min(left, right) - height[i]`

#### 11660. [구간 합 구하기 5](./silver1/boj_11660.cpp)

> DP

- `arr[i][j]`  = (1,1)에서 (i,j) 까지의 합

- 사각형을 그리면, (x1,y1), (x1,y2), (x2,y1), (x2,y2)가 나온다.
- 제일 큰 사각형(x2,y2)에서 나머지 3개의 사각형들을 빼면 (x1,y1) 부터 (x2,y2) 까지의 합을 구할 수 있다.
  - `arr[x2][y2] - arr[x2][y1-1] - arr[x1-1][y2] + arr[x1-1][y1-1]`

## <10.14>

#### 17626. [Four Squares](./silver4/boj_17626.py)

- 전체 돌면서 제곱수 개수가 1, 2, 3이 되는지 체크
- 아니면 4 출력

#### 17219. [비밀번호찾기](./silver4/boj_17219.py)

#### 1764. [듣보잡](./silver4/boj_1764.py)

- dict이용

#### 11047. [동전 0](./silver2/boj_11047.py)

- 큰 동전부터 넣으면서 반복

#### 9095. [1,2,3 더하기](./silver3/boj_9095.py)

- `dp[1] = 1, dp[2] = 2, dp[3] = 4`

- `dp[i] = dp[i-1] + dp[i-2] + dp[i-3]`

#### 1149. [RGB거리](./silver1/boj_1149.cpp)

- DP
- 바로 앞 행에서 다른색 2개중에 더 작은값 더해서 계산

## <10.15>

#### 17404. [RGB거리 2](./gold4/boj_17404.cpp)

- RGB거리와 같은 문제인데, 시작지점과 끝지점이 같으면 안된다는 조건이 추가됨
- 시작지점 저장하기 위해 배열의 차원을 하나 늘려서 `RGB[3][1001][3]`로 설정
  - `RGB[end][n][start]` 
  - start(시작컬러)에서 시작해서 end(현재컬러)까지 n번 집까지의 최소비용

- RGB 거리와 동일하게 계산 이후 마지막에 start = end인 경우를 제외하고 최솟값을 구해서 출력

## <10.16>

#### 1932. [정수 삼각형](./silver1/boj_1932.py)

- DFS로 하면 시간초과 발생 => DP
  - 위의 2개 중에 큰 값 더하면서 저장 후 마지막 라인의 최댓값 출력

#### 15650. [N과 M(2)](./silver3/boj_15650.py), 15652. [N과 M(4)](./silver3/boj_15652.py), 15654. [N과 M(2)](./silver3/boj_15654.py), 15657. [N과 M(5)](./silver3/boj_15657.py)

- 단순 백트래킹

#### 15663. [N과 M(9)](./silver2/boj_15663.py)

- 문자열로 처리 시 sort할때 두자리 수 19, 2 의 경우 19가 먼저오는 경우가 생긴다.
- int 형으로 sort한 후 출력해야 한다.



## <10.17>

#### 9252. [LCS 2](./gold5/boj_9252.py)

- [LCS](#<10.09>) 에서 문자열까지 출력하는 문제이다.
- DP에 저장할 때 문자열로 저장한다.
  -  `      dp[i+1][j+1] = dp[i][j+1] if len(dp[i][j+1]) > len(dp[i+1][j]) else dp[i+1][j]` (이전까지의 최대길이를 저장)

#### 1647. [도시 분할 계획](./gold4/boj_1647.py)

- MST
- prim으로 최소 신장 트리 구한 후, 제일 긴 cost를 가진 간선 제거
- [Kruskal풀이](./gold4/boj_1647.cpp)
  - 가중치를 저장하고 마지막 가중치를 제외한 합을 구하면 된다.
  - `#include<numeric>`
  - `accumulate(v.begin(), v.end()-1, 0);`
    - 시작, 끝, 합의 초기값

## <10.18>

#### 2407. [조합](./silver3/boj_2407.py)

- DP에 1~n까지 곱을 저장해둔 후 `nCm = dp[n]//dp[n-m]//dp[m]` 출력

#### 14500. [테트로미노](./gold5/boj_14500.py)

- DFS로 길이가 4가 될때까지 돌면서 최댓값 갱신하고, 마지막  모양은 따로 생각해서 최댓값 갱신한다.
- **시간 줄이기**
  - 모든 칸 중 최댓값을 구해놓고, DFS를 돌 때, 나머지 모든 칸이 최대값인 경우에 현재 저장된 ans보다 커질 수 있는지 체크 후 가지치기한다.
  - 마지막 모양의 경우 한 칸 이동한 후에 다시 원래 위치로 돌아와서 DFS를 하는것과 같으므로,
  - `lev==2` 인 경우에 DFS 시작지점으로 돌아가면 한 번에 마지막 모양까지 체크가 가능하다.

## <10.19>

#### 1987. [알파벳](./gold4/boj_1987.cpp)

- DFS 사용
- 파이썬 시간초과 나서 C++로 했더니 통과

## <10.20>

#### 2776. [암기장](./silver4/boj_2776.py)

- Counter 사용

## <10.21>

#### 20166. [문자열 지옥에 빠진 호석](./gold5/boj_20166.cpp)

- DFS
- 8방향으로 DFS 돌면서 map으로 몇번 나왔는지 체크 후 출력
- `map.find(s)` : s가 있으면 iterator 반환, 없으면 `map.end()` 반환
  - `(key:value): iter->first, iter->second` 로 접근

## <10.22>

#### 7682. [틱택토](./gold5/boj_7682.cpp)

- 첫번째 사람(X)이 성공하는 경우, 두번째 사람(Y)이 성공하는 경우 나눠서 생각한다.
- 가능한 경우와 불가능한 경우의 수를 생각해서 조건 분기해서 해결

## <10.23>

#### 1629. [곱셈](./silver1/boj_1629.py)

- `pow(a,b,c) = a**b % c`를 log를 이용해서 빠르게 계산해줌

#### 16564. [히오스 프로게이머](./silver1/boj_16564.py)

- 이분탐색
- 정렬 후 최솟값과 최솟값에 k를 더한 값에서 이분탐색을 이용해서 k번으로 mid값을 만들 수 있는지 체크한다.

## <10.24>

#### 1806. [부분합](./gold4/boj_1806.py)

- 투포인터 사용
- l, r 모두 0에서 시작하면서 total에 `nums[l], nums[r]`을 더하고 빼가면서 체크
- 처음에 오답이 나왔는데 아래의 답을 1,2,3,4,5를 모두 더한 5로 구하고 while문을 종료했었다.
  - `total > s` 일때에도 while문 반복하도록 조건을 걸어서 해결했다.

```python
5 11
1 2 3 4 5
# 3
```

## <10.25>

#### 1915. [가장 큰 정사각형](./gold4/boj_1915.py)

- DP
- (i,j)일때 가장 큰 정사각형의 길이는 왼쪽, 위쪽, 대각선의 최솟값에 1을 더한 값이다.
  - `DP[i][j] = min(dp[i][j-1], dp[i-1][j], dp[i][j]) + 1`
- 처음에 원본배열을 바로 바꾸다가 오답 발생 => 1이어야 하는 칸을 0으로 바꿔버려서 뒤의 dp값들이 달라진다.
  - 원본 배열 복사해서 사용
  - max값을 갱신해줬는데 1,1부터 n-1, m-1까지 돌다보니 row, col이 0일때만 1이 존재하면 max값을 갱신하지 못하는 문제가 있었다.
    - dp 배열을 모두 만든 이후에 최댓값을 찾는다.

## <10.26>

#### 23259. [Celebrity](./gold1/boj_23259.py)

- 두 그래프 사이가 동일한 그래프인지 판별하는 문제.
- 두 그래프가 같으려면, 각 노드마다 연결된 개수가 같아야 하고, 그 연결된 노드에서 연결되어있는 노드의 수가 같아야 한다.
  - 따라서 인접 행렬에 연결된 길이와, 그 노드에 연결된 길이를 저장한 후 str 형식으로 딕셔너리에 저장한다.
  - 개수를 센 후, 1번만 나온 별의 개수를 세서 출력한다.
  - `{'[1, 2, 2] [1, 2, 2] [2, 1] [2, 1] [2, 2, 2]': 2, '[0] [1, 2, 2, 3] [2, 3, 2] [2, 3, 2] [3, 1]': 1}` 와 같은 형식으로 dict에 저장했다.
- 개수를 세는 과정에서 리스트를 그대로 저장 후 count를 이용해서 1번만 나오는 것을 세었더니 시간초과가 발생했다.
- in을 이용해서 이미 존재하는 리스트면 ans에 -1을 하는 방식으로 계산하면 된다고 생각했는데, 예제는 맞지만 동일한 별의 개수가 많아지면 틀린 방법이 된다.

## <10.27>

#### 1005. [ACM Craft](./gold3/boj_1005.py)

- 위상정렬
- [게임개발](# <09.27>) 문제와 입력만 다르고 풀이는 같다.

#### 12852. [1로 만들기2](./silver1/boj_12852.py)

- DP
- 각각 1부터 n의 값을 가진 DP 배열을 생성한 후, 우선순위 낮은 순서대로 dp를 갱신한다.
  - +1 => 2의 배수 => 3의 배수 순서로 갱신

- 출력할 때는 n부터 역순으로 앞의 조건을 만족하는지 체크 후 순서대로 출력한다.

## <10.28>

#### 2960. [에라토스테네스의 체](./silver4/boj_2960.py)

## <10.29>

#### 1408. [24](./bronze/boj_1408.py)

- 시간계산

#### 1292. [쉽게 푸는 문제](./silver5/boj_1292.py)

- 배열 만들어서 계산

#### 12849. [본대 산책](./silver1/boj_12849.cpp)

- DP
- 모든 점에 대해서 연결된 노드의 DP를 더하면서 DP갱신하면서 D번 반복

## <10.30>

#### 12850. [본대 산책2](./gold1/boj_12850.py)

#### 14289. [본대 산책3](./gold1/boj_14289.py)

- 행렬의 제곱을 이용하는 문제
- 행렬을 D번 곱하면,  `arr[i][j]`는 i에서 j 까지 D번동안 이동하는 총 경우의 수가 나온다.
- 여기서 구하려는 D을 2로 나누면서 반복하면, D번을 곱하지 않고 시간복잡도를 log로 줄일 수 있다.
  - 홀수일땐, 자기 자신으로 돌아오는 행렬을 곱하고
  - 짝수인 경우에는 D을 2로 나눈 후, 제곱을 한다

## <10.31>

#### 17071. [숨바꼭질5](./gold1/boj_17071.py)

- BFS
- 짝수일때, 홀수일때 나눠서 visited 처리를 한다.
  - 짝수 or 홀수일때 n을 방문했으면 그 이후로 짝수번 시간에는 무조건 n을 방문할 수 있다. (+1, -1 할 수 있기 때문)
- cnt 번째에 이동할 수 있는 곳들을 queue에 넣은 후 방문처리 후, 둘이 만났으면 cnt, 못만나고 500000을 넘으면 -1

## <11.01>

#### 23304. [아카라카](./silver2/boj_23304.py)

- 재귀로 1이 될때까지 반복해서 pallindrome 체크하면서 akaraka pallindrome인지 판별

## <11.02>

#### 23292. [코딩 바이오리듬](./bronze/boj_23292.py)

#### 23321. [홍익 댄스 파티](./bronze/boj_23321.py)

- 단순 구현

## <11.03>

#### 14003. [가장 긴 증가하는 부분 수열 5](./platinum5/boj_14003.py)

- [가장 긴 증가하는 부분수열 2](#12015.-가장-긴-증가하는-부분수열2)와 동일하게 이분탐색을 이용하여 LIS를 구한다.
- 구하면서 각 위치에서의 최장 길이를 구한다.
- 역방향으로 최대 길이에서 1씩 빼면서 각 위치에서의 최장 길이와 같은 경우를 저장한 후 역순으로 출력한다.

## <11.04>

#### 11055. [가장 큰 증가 부분 수열](./silver2/boj_11055.py)

- DP
- 앞에서부터 시작해서 자기 자신보다 앞에 있는 배열까지 비교
- 이전값에 자기자신 더한 값과 기존 값 중 최댓값 갱신
  - `      dp[i] = max(dp[i], dp[j] + arr[i])`

## <11.05>

#### 4386. [별자리 만들기](./gold4/boj_4386.py)

- 각 별자리의 좌표 사이 길이를 가중치로 하는 edges 리스트를 만들고 Kruskal 사용

#### 2568. [전깃줄 - 2](./platinum5/boj_2568.py)

- [가장 긴 증가하는 부분수열 5](#14003.-가장-긴-증가하는-부분-수열 5)와 같은 문제
- A전깃줄 기준으로 정렬 이후, LIS 리스트를 구한 후 LIS 리스트에 해당하지 않는 원소 출력

#### 17213. [과일 서리](./silver1/boj_17213.py)

- `H(n,r) = C(n+r-1,r)`
  - r = m - n : 종류별로 1개씩 훔친 상태에서 중복조합

## <11.06>

#### 14620. [꽃길](./silver2/boj_14620.py)

- 백트래킹으로 놓을 수 있는지 체크하면서 씨앗 3개 심었을 때 비용 최솟값 갱신

## <11.07>

#### 23352. [방탈출](./gold5/boj_23352.py)

- 0이 아닌 모든 좌표에서 BFS를 돌면서 최대 이동 가능한 거리와 크기를 구한다.
- 길이와 크기순으로 정렬 후 제일 큰 값을 출력한다.

## <11.08>

#### 2166. [다각형의 면적](./gold5/boj_2166.py)

- 좌표평면상에 n개의 점이 있을때 넓이 구하는 법
  - [신발끈 공식](https://namu.wiki/w/%EC%8B%A0%EB%B0%9C%EB%81%88%20%EA%B3%B5%EC%8B%9D) 

#### 2751. [수 정렬하기2](./silver5/boj_2751.py)

- merge sort

#### 10989. [수 정렬하기3](./silver5/boj_10989.py)

- counting sort

#### 10845. [큐](./silver4/boj_10845.py)

- queue

## <11.09>

#### 1158. [요세푸스 문제](./silver5/boj_1158.py)

- deque 회전 후 맨 앞의 값 pop 하면서 저장

#### 10814. [나이순 정렬](./silver5/boj_10814.py)

- merge sort (=stable sort이기 때문)

#### 2467. [용액](./gold5/boj_2467.py)

- 투 포인터
- 정렬 후 양 끝에 포인터를 두고 합이 음수면 start 오른쪽으로, 양수면 end 왼쪽으로 이동하면서 두 용액 저장

## <11.10>

#### 2473. [세 용액](./gold4/boj_2473.py)

- 정렬 후 0번부터 n-3번 인덱스의 값을 초기값으로 설정
- 나머지 범위에서 용액 문제처럼 투 포인터를 이용해서 반복

## <11.11>

#### 1927. [최소 힙](./silver1/boj_1927.py)

- heapq

#### 10866. [덱](./silver4/boj_10866.py)

- deque

## <11.12>

#### 18111. [마인 크래프트](./silver3/boj_18111.py)

- 브루트포스로 0~256 높이까지 모두 확인한다.
- 3중 포문을 돌면 시간초과가 발생하기 때문에, 블록들의 높이를 dict 형태로 저장해둔 후 계산했다.

## <11.13>

#### 17615. [볼 모으기](./silver1/boj_17615.py)

- 왼쪽으로 R or B 모으는 경우, 오른쪽으로 R or B모으는 4가지 경우 중 최솟값을 구한다.
- 초기값에 R과 B의 개수 중 작은 값을 저장 (모으려는 방향의 끝에 있는 값과 반대를 모으는 경우)
- 모으려는 곳의 처음 값이 R이면 R을 모으고, B면 B를 모아서 최솟값을 갱신한다.

## <11.14>

#### 11502. [세 개의 소수 문제](./silver4/boj_11502.py)

- 에라토스테네스의 체로 소수 구해놓고, 3중 for문으로 검사

## <11.15>

#### 3079. [입국심사](./silver1/boj_3079.py)

- 이분탐색

#### 23559. [밥](./silver1/boj_23559.py)

- DFS 하면 시간초과
- 먼저 1000원 메뉴를 전부 선택하고, 5000원 메뉴와 1000원 메뉴의 차이 순서로 정렬 후, 5000원 짜리 메뉴로 변경해본다.
- 5000-1000 = 4000원보다 작아지면 종료

## <11.16>

#### 23560. [약](./silver2/boj_23560.py)

- 앞에서 시작하는 경우와 뒤에서 시작하는 경우로 나눠서 생각한다.
- 앞에서 3개 먹는것과 뒤에서 3개 먹는건 앞에서 시작하냐 뒤에서 시작하냐에 따라 같다.
- 약을 먹는 경우의 수는 앞,뒤쪽에서 다 먹거나, 왼쪽아침-왼쪽점심-오른쪽저녁, 오른쪽아침-오른쪽점심-왼쪽저녁의 3가지 경우이다.
- 마지막에 약이 1개 남으면 1가지 경우밖에 없다.
- 따라서, 2 * 3 ** (N-1)

## <11.17>

#### 23561. [Young한 에너지는 부족하다.](./silver2/boj_23561.py)

- 입력을 정렬한 후 크게 3등분을 했을 때, 작은거 하나, 큰거 하나, 중앙 하나씩 뽑으면 모두 중앙에 가까운 에너지를 가질 수 있다.
- 따라서, `crew[n:2*n]` 의 최대, 최소값의 차이가 에너지 차이이다.

## <11.18>

#### 1181. [단어 정렬](./silver5/boj_1181.py)

#### 20291. [파일 정리](./silver3/boj_20291.py)

- 정렬

## <11.19>

#### 11725. [트리의 부모 찾기](./silver2/boj_11725.py)

- 1부터 dfs로 연결된 노드 체크

## <11.20>

#### 2023. [신기한 소수](./gold5/boj_2023.py)

- 한자리 소수인 2,3,5,7만 맨 앞에 올 수 있다.
- 뒤에 올 수 있는 수는 짝수와 5는 불가능하므로 1,3,7,9가 올 수 있다.
- 2,3,5,7로 시작해서 1,3,7,9를 붙이면서 소수인지 판별한 다음 n자리수가 되었을 때 출력한다.

#### 1725. [히스토그램](./platinum5/boj_1725.py)

- stack에 index값을 넣으면서, stack의 top 값이 현재 histogram의 높이보다 높으면, 앞부분의 최대 넓이를 계산 후 갱신한다.

## <11.21>

#### 6549. [히스토그램에서 가장 큰 직사각형](./platinum5/boj_6549.py)

- 1725와 동일한 문제

#### 16565. [N포커](./gold1/boj_16565.py)

- 52개 중에서 k개를 뽑는 조합을 저장해둔다. `nCk = n-1Ck-1 + n-1Ck`
- `c[13][i//4] * c[52-i][num-i]`
  - 13개의 쌍에서 포카드 구하는 경우의 수 * 52-i개에서 num-i개 뽑는경우
- 짝수개의 쌍을 뽑는 경우는 빼고, 홀수개를 뽑는 경우는 더한다. (포함 - 배제 원리)

## <11.22>

#### 2239. [스도쿠](./gold4/boj_2239.cpp)

- 가로, 세로, 3*3 체크하면서 백트래킹
- C++에서 string으로 입력 받을 때, int로 바꿀 때 `'0'` 빼줘야 원하는 값 입력 받을 수 있음.

## <11.23>

#### 23629. [이 얼마나 끔찍하고 무시무시한 수식이니](./gold5/boj_23629.py)

- 영어와 숫자를 replace로 변환한 후 연산자를 queue에 담아서 순서대로 계산한다.
- 연산자가 연속으로 나오면 Madness! 출력
- 파이썬의 경우 `ONE-EIGHT/THREE= -THREE`가 나오기 때문에 음수 나눗셈의 경우 따로 처리해줘야 한다.

## <11.24>

#### 1463. [1로 만들기](./silver3/boj_1463.py)

- DP

#### 2583. [영역 구하기](./silver1/boj_2583.py)

- BFS

## <11.25>

#### 2565. [전깃줄](./silver1/boj_2565.py)

- LIS

#### 1503. [세 수 고르기](./silver3/boj_1503.py)

- 완전탐색

## <11.26>

#### 1655. [가운데를 말해요](./gold2/boj_1655.py)

- 최소, 최대 힙에 하나씩 넣으면서 max_heap의 최댓값이 min_heap의 최솟값보다 크면 양쪽의 최대, 최소값을 빼서 반대쪽에 넣어서 정렬한다.
- 한번 진행할 때마다 max_heap의 최대값을 출력한다.

## <11.27>

#### 2302. [극장 좌석](./silver1/boj_2302.py)

- n번째 자리를 추가할 때, 마지막에 추가하는경우, 바로 앞과 교환하는 경우 2가지가 있어서
  - `dp[n] = dp[n-1] + dp[n-2]`가 된다.
- vip 자리를 기준으로 연속된 자리를 앉는 경우의 수를 곱하면 전체 경우의 수를 구할 수 있다.

## <11.28>

#### 10870. [피보나치 수 5](./bronze/boj_10870.py)

- DP

#### 1874. [스택 수열](./silver3/boj_1874.py)

- stack

## <11.29>

#### 23738. [Ресторан](./bronze/boj_23738.py)

#### 23739. [벼락치기](./bronze/boj_23739.py)

- 단순 구현

## <11.30>

#### 23740. [버스 노선 개편하기](./gold5/boj_23740.py)

- 스위핑 알고리즘
- left 기준으로 정렬 후, 한 번씩 돌면서 right값만 비교하면서 left, right, val을 갱신해준다.

## <12.01>

#### 1012. [유기농 배추](./silver2/boj_1012.py)

- BFS

## <12.02>

#### 1182. [부분수열의 합](./silver2/boj_1182.py)

- 비트마스킹을 이용해서 전체 부분집합을 구한 후 s 갯수 체크

## <12.03>

#### 1208. [부분수열의 합 2](./gold1/boj_1208.py)

- n의 최댓값이 40이기때문에 시간초과
- 배열을 절반으로 나눠서 각각 비트마스킹으로 전체 부분집합 구한다.
- 정렬 후 투포인터를 이용해서 right, left를 이동하면서 전체 개수 체크

## <12.04>

#### 1743. [음식물 피하기](./silver1/boj_1743.cpp)

- BFS

#### 11727. [2xn 타일링 2](./silver3/boj_11727.py)

- DP
- `DP[n]` = n-1번째에 새로운 타일만 붙이는 경우(`DP[n-1]`) +  n-2번째에 붙여서 2*2를 만드는 경우 2가지 ( `DP[n-2] * 2` )

## <12.05>

#### 2193. [이친수](./silver3/boj_2193.py)

- DP

#### 1527. [금민수의 개수](./silver1/boj_1527.py)

- DFS

## <12.06>

#### 15824. [너 봄에는 캡사이신이 맛있단다](./gold1/boj_15824.py)

- 전체 스코빌 지수를 정렬한다.
  - 정렬 후 각각의 값이 최솟값, 최댓값이 되는 경우의 수는 자기보다 앞의 수에서만 선택하는 경우, 뒤에서만 선택하는 경우로
    -  `2**i, 2**(n-i)` 이다.
- 2의 n제곱을 MOD로 나눈 수를 모두 저장해 둔 후 계산해야 시간안에 풀 수 있다.

#### 15721. [번데기](./bronze/boj_15721.py)

- 번-데기 전체를 문자열로 만들어 놓고 몇번째에 나오는지 찾기

## <12.07>

#### 2623. [음악프로그램](./gold2/boj_2623.cpp)

- 위상정렬
- 각 PD마다 입력이 순서대로 들어와서 이전 값을 저장하는 작업 필요

#### 7490. [0 만들기](./gold5/boj_7490.py)

- 백트래킹
- +, -, '' 넣으면서 eval로 계산해서 0이면 저장, 마지막에 공백인 경우 " "로 바꾸기

## <12.08>

#### 13707. [합분해 2](./gold4/boj_13707.cpp)

- DP

  | k\n  | 0    | 1    | 2    | 3    | 4    |
  | ---- | ---- | ---- | ---- | ---- | ---- |
  | 1    | 1    | 1    | 1    | 1    | 1    |
  | 2    | 1    | 2    | 3    | 4    | 5    |
  | 3    | 1    | 3    | 6    | 10   | 15   |
  | 4    | 1    | 4    | 10   | 20   | 35   |

  - `DP[i][j] = dp[i-1][j] + dp[i][j-1]`
  - k번 반복하면 1차원 배열로 해결 가능

#### 13019. [A를 B로](./silver2/boj_13019.py)

- 뒤에서부터 A, B 이동하면서 체크

## <12.09>

#### 23742. [Player-based Team Distribution](./gold4/boj_23742.py)

- 처음에는 `+, -` 만 나눠서 계산하면 될 줄 알았는데, 1,2,3,4,-1 과 같은 경우 `-`도 넣어야 최대가 되는 경우 존재
- `-`를 정렬한 후 절대값이 작은 값부터 하나씩 넣을 수 있는지 체크한다.
- 못넣는 경우가 나오면 더이상 검사하지 않고 종료

#### 14225. [부분수열의 합](./silver1/boj_14225.cpp)

- 비트마스킹으로 전체 합 체크한 후 체크 안한 것 출력

## <12.10>

#### 15927. [회문은 회문아니야!!](./gold5/boj_15927.py)

- 전체 문자가 같은 문자인 경우 = 불가능

- 전체가 회문인 경우 = 앞이나 뒤에서 1개만 빼면 회문 x
- 회문이 아닌 경우 = 전체 길이

#### 1018. [체스판 다시 칠하기](./silver5/boj_1018.py)

- 8 * 8 체스판으로 나눈 후 완전탐색

## <12.11>

#### 11170. [0의 개수](./silver5/boj_11170.cpp)

- 완전탐색

#### 5052. [전화번호 목록](./gold4/boj_5052.py)

- dict

## <12.12>

#### 1013. [Contact](./gold5/boj_1013.py)

- 정규식으로 완전히 일치(fullmatch)하는지 체크
- (= [2671.잠수함식별](./gold5/boj_2671.py))

#### 21925. [짝수 팰린드롬](./gold3/boj_21925.py)

- 처음에 각 숫자 짝이 짝수개인지 체크해서 아니면 -1

- 왼쪽부터 시작해서 팰린드롬이 되는지 체크

## <12.13>

#### 23830. [제기차기](./gold4/boj_23830.py)

- 정렬 후 이분탐색으로 k미만, k+r초과인 숫자가 들어갈 위치 찾아서 계산

## <12.14>

#### 15732. [도토리 숨기기](./gold2/boj_15732.py)

- 도토리 개수를 기준으로 이분탐색 하면서 규칙을 계산해서 가능한지 체크

## <12.15>

#### 4095. [최대 정사각형](./gold5/boj_4095.cpp)

- (i,j) = 1일때 왼쪽, 위쪽, 대각선이 모두 1이어야 정사각형이다.
  - `DP[i][j] = min(dp[i][j-1], dp[i-1][j], dp[i][j]) + 1`

#### 1072. [게임](./silver3/boj_1072.py)

- x의 최대, 최소값 중에서 이분탐색으로 z가 변하는 값을 찾는다
- `(int)(y / x * 100) `으로 하면 y / x 계산에서 오차가 생겨서 오답이 된다
  - `(int)(100 * y / x)` 

## <12.16>

#### 5212. [지구 온난화](./silver2/boj_5212.cpp)

- 처음 땅 위치 저장후 인접 4칸 체크해서 바다로 변하는 위치 저장 후 바다로 변경
- 땅을 포함하는 최소 직사각형 r, c 값 저장 후 출력

## <12.17>

#### 4097. [수익](./silver2/boj_4097.cpp)

- 입력받으면서 total을 더하면서 최댓값 계산
- 0보다 작아지면 더하면 줄어드는 구간이므로 0으로 초기화

## <12.18>

#### 4963. [섬의 개수](./silver2/boj_4963.cpp)

- 8방향으로 BFS

## <12.19>

#### 1052. [물병](./silver1/boj_1052.cpp)

- n을 2진수로 바꿨을때 나오는 1의 개수가 물병의 개수이다.
- 1이 k개가 될 때까지 1개씩 추가하면서 추가해야 하는 물병의 최솟값을 찾는다.

## <12.20>

#### 17836. [공주님을 구해라!](./gold5/boj_17836.cpp)

- 그람을 가진 상태(z=1)와 없는 상태(z=0)에서 방문하는 `visited[][][z]`를 나눠서 BFS

## <12.21>

#### 16946. [벽 부수고 이동하기 4](./gold2/boj_16946.cpp)

- 처음에 벽에서 시작해서 초기화하면서 완전탐색 하니 시간초과 (n=1000, m=1000 이라서)
- bfs를 한번만 돌려서 체크해논 후에 벽에서 4방향만 탐색하는 방식으로 변경
  - 4방향 중에 같은 area인지 체크 필요
  - visited에 pair로 (인접한 칸의 수, area 번호) 체크한 후 계산해서 해결

## <12.22>

#### 10808. [알파벳 개수](./bronze/boj_10808.cpp)

#### 2445. [별 찍기 - 8](./bronze/boj_2445.cpp)

#### 2446. [별 찍기 - 9](./bronze/boj_2446.cpp)

## <12.23>

#### 1406. [에디터](./silver3/boj_1406.cpp)

- 연결리스트
- STL list는 이중 연결 리스트여서 야매 방식보다 메모리가 더 많이 사용된다.
  - [에디터 - 2번 풀이](./silver3/boj_1406-2.cpp)

#### 5397. [키로거](./silver3/boj_5397.cpp)

- 연결리스트

## <12.24>

#### 2493. [탑](./gold5/boj_2493.cpp)

- 스택
- 값을 하나씩 넣으면서 현재 스택에 자신보다 큰 값이 있는지 체크
- 없으면 pop해서 버리고 자기자신 push 하면서 반복

## <12.26>

#### 6198. [옥상 정원 꾸미기](./gold5/boj_6198.cpp)

- 스택
- 현재 높이보다 낮은 값들은 pop하면서 스택에 담긴 빌딩의 수를 더한다.

## <12.27>

#### 18258. [큐 2](./silver4/boj_18258.cpp)

#### 2164. [카드2](./silver4/boj_2164.cpp)

- 큐

## <12.28>

#### 1021. [회전하는 큐](./silver4/boj_1021.cpp)

- 덱

#### 5430. [AC](./gold5/boj_5430.cpp)

- cpp로 다시 풀이

#### 4949. [균형잡힌 세상](./silver4/boj_4949.cpp)

- 스택

## <12.29>

#### 3986. [좋은 단어](./silver4/boj_3986.cpp)

- 스택

#### 10799. [쇠막대기](./silver3/boj_10799.cpp)

- 스택에 넣으면서 레이저면 스택에 담긴 수만큼 더하고 아니면 1씩 더하면서 계산

#### 2504. [괄호의 값](./silver2/boj_2504.cpp)

- 앞에서부터 괄호에 따라 값을 계산하고 스택에 추가하면서 가장 작은 괄호가 맞으면 더한다.
- 괄호쌍이 안맞으면 바로 종료

## <12.30>

#### 1926. [그림](./silver1/boj_1926.cpp)

#### 2178. [미로 탐색](./silver1/boj_2178.cpp)

#### 7576. [토마토](./silver1/boj_7576.cpp)

- BFS

## <12.31>

#### 4179. [불!](./gold4/boj_4179.cpp)

- 불, 지훈이 기준으로 BFS 2번 돌면서 지훈이가 먼저 이동할 수 있는지 체크

#### 1697. [숨바꼭질](./silver1/boj_1697.cpp)

- 1차원 BFS

#### 5427. [불](./gold4/boj_5427.cpp)

- 4179번과 동일하지만, 불이 없는 경우에 25%에서 오답이 발생한다.
- 또한, tc마다 초기화 해줘야한다.

# 2022

## <1.1>

#### 24039. [2021은 무엇이 특별할까?](./silver5/boj_24039.py)

- 소수 구해놓고 계산

#### 24040. [예쁜 케이크](./silver2/boj_24040.cpp)

- ab = n, a+b = 0(mod 3) 을 만족하는 수 찾기
- 완전탐색은 시간초과나므로, a=b=3k, a=3k+1, b=3k+2인 경우를 생각했을 때, 3으로 나눈 나머지가 2이거나 9의 배수인 지 체크한다.

#### 24041. [성싶당 밀키트](./gold3/boj_24041.cpp)

- 이분탐색으로 x일 탐색
- 세균 수 내림차순 정렬 후 k개 제거하면서 확인

## <1.2>

#### 1600. [말이 되고픈 원숭이](./gold4/boj_1600.cpp)

- BFS

- `visited[x][y][z]`로 나이트 이동 횟수 z에 따라 방문 표시한다.

#### 23885. [비숍 투어](./bronze/boj_23885.cpp)

- n,m이 1인 경우 생각해줘야함

#### 2146. [다리 만들기](./gold3/boj_2146.cpp)

- 연결된 섬마다 체크 후, 각 섬의 가장자리부터 bfs를 해서 다른 섬을 만나는 최솟값을 구한다.

## <1.3>

#### 13549. [숨바꼭질 3](./gold5/boj_13549.cpp)

- BFS 할때, 순간이동 한곳을 +1, -1 하기 전에 큐에 넣어야한다.
- 순간이동시, 0일때 예외처리 필요

## <1.4>

#### 9466. [텀 프로젝트](./gold3/boj_9466.cpp)

- DFS로 사이클 체크
- state 배열에 연결된 값을 시작값으로 변경 후, 사이클이면 -1로 변경

## <1.5>

#### 1629. [곱셈](./silver1/boj_1629.cpp)

#### 11729. [하노이 탑 이동 순서](./silver1/boj_11729.cpp)

#### 1074. [Z](./silver1/boj_1074.cpp)

- 재귀

## <1.6>

#### 17478. [재귀함수가 뭔가요?](./silver5/boj_17478.cpp)

#### 2630. [색종이 만들기](./silver3/boj_2630.cpp)

#### 1992. [쿼드트리](./silver1/boj_1992.cpp)

#### 2448. [별 찍기 - 11](./gold4/boj_2448.cpp)

- 3번째 줄까지의 별이 반복되기 때문에, 삼각형의 세 점에서 재귀를 통해 n=3일때 별을 board에 저장해준다.
- board에 별을 출력할 때 범위를 정확하게 출력하지 않으면 오답이 나온다. (출력 주의)

## <1.7>

#### 15649. [N과 M (1)](./silver3/boj_15649.cpp)

#### 15650. [N과 M (2)](./silver3/boj_15650.cpp)

#### 15651. [N과 M (3)](./silver3/boj_15651.cpp)

#### 9663. [N-Queen](./gold5/boj_9663.cpp)

#### 1182. [부분수열의 합](./silver2/boj_1182.cpp)

- 백트래킹

#### 15662. [톱니바퀴 (2)](./silver1/boj_15662.cpp)

- 구현

## <1.8>

#### 15655. [N과 M (6)](./silver3/boj_15655.cpp)

#### 15656. [N과 M (7)](./silver3/boj_15656.cpp)

- 백트래킹

## <1.9>

#### 13460. [구슬 탈출 2](./gold1/boj_13460.cpp)

- BFS
- 빨간구슬, 파란구슬 동시에 이동하면서 방문처리
- 겹쳐친 경우 뒤에서 출발한 구슬 한칸 뒤로 처리
- [구슬 탈출 1](./gold3/boj_13459.cpp), [구슬 탈출 3](./gold1/boj_15644.cpp), [구슬 탈출 4](./gold1/boj_15653.cpp) 모두 유사한 문제로 조건 추가 제거 후 해결

#### 2206. [벽 부수고 이동하기](./gold4/boj_2206.cpp)

- python 시간초과로 바뀌어서 cpp로 다시 풀이
- 벽 부수는 경우 고려해서 방문처리

#### 14502. [연구소](./gold5/boj_14502.cpp)

- 코드 정리

## <1.10>

#### 15664. [N과 M (10)](./silver2/boj_15664.cpp)

- 재귀를 들어갈 때 k번째 수가 같은 값이 되지 않도록 처리해야함

#### 15665. [N과 M (11)](./silver2/boj_15665.cpp)

- n과 m (10) 에서 중복만 허용

#### 15666. [N과 M (12)](./silver2/boj_15666.cpp)

- n과 m (11)에서 앞의 값보다 크거나 같은지 체크하는 조건 추가

## <1.11>

#### 14890. [경사로](./gold3/boj_14890.cpp)

- 가로, 세로 총 2N개의 길에 경사로 설치 가능한지 조건에 맞게 체크

#### 15683. [감시](./gold5/boj_15683.cpp)

- 백트래킹으로 모든 경우의 수를 다 감시해본 후 최솟값 출력

## <1.12>

- 정렬1 기본문제
  - [배열 합치기](./silver5/boj_11728.cpp), [수 정렬하기 5](./silver5/boj_15688.cpp), [좌표 정렬하기](./silver5/boj_11650.cpp), [좌표 정렬하기2](./silver5/boj_11651.cpp)

## <1.13>

- 정렬2 연습문제
  - [수 정렬하기 5](./silver5/boj_15688.cpp) : counting sort풀이 추가
  - [시리얼 번호](./silver3/boj_1431.cpp)
  - [카드](./silver4/boj_11652.cpp)

## <1.14>

#### 5648. [역원소 정렬](./silver4/boj_5648.cpp)

- STL의 reverse, stoll 사용

#### 2910. [빈도 정렬](./silver3/boj_2910.cpp)

- stable_sort 사용

#### 7796. [먹을 것인가 먹힐 것인가](./silver3/boj_7795.cpp)

- 정렬 후 비교

## <1.15>

#### 11656. [접미사 배열](./silver4/boj_11656.cpp)

- 접미사 만든 후 정렬

#### 10825. [국영수](./silver4/boj_10825.cpp)

- 조건에 맞게 cmp 비교함수 설정 후 정렬

## <1.16>

- DP 연습문제
  - [1463. 1로 만들기](./silver3/boj_1463.cpp)
  - [9095. 1,2,3 더하기](./silver3/boj_9095.cpp)
  - [2579. 계단 오르기](./silver3/boj_2579.cpp)
    - 계단을 밟는 경우와 밟지 않는 경우를 기준으로 생각 가능
  - [11726. 2xn 타일링](./silver3/boj_11726.cpp)

