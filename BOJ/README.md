## <03.06>

### 2447. [별찍기 -10](./silver1/boj_2447.py)

- 머리로는 공백을 찍거나 별을 찍는게 생각이 되는데 구현이 되지 않았다.

- 1 2 3

- 4 5 6

- 7 8 9

- 위와 같이 3*3이 있을때, 5번만 공백이고 나머지는 *

- 이러한 구조를 하나로 봐서 1 ~ 9 까지 들어가는 식으로 반복된다.

-  별을 채워놓은 상태에서 공백을 찍고싶었는데 생각대로 되지 않아서 하나씩 돌면서 별을 찍는 방식으로 코드를 작성하였다.

  - 전체를 다 돌면서 별을 찍어서 시간이 오래걸리는것 같다.



- 💡 다음과 같이 zip 과 join 을 이용하면 간단하게 구현할 수 있다.

  - 파이썬의 장점을 이용하자!

  ```python
  def concatenate(r1, r2):
      return [''.join(x) for x in zip(r1, r2, r1)]
  ```

  



### 7562. [나이트의 이동](./silver2/boj_7562.py)

- BFS를 구현하는 방법에 대해 복습할 수 있었다.
- 시간을 줄이는 방법에 대해 더 생각해봐야 할듯하다.



## <03.27>

### 11399. [ATM](./silver3/boj_11399.py)

- 오름차순으로 정렬 후 더하기



### 16953. [A -> B](./silver1/boj_16953.py)

- queue 이용
- queue에 현재 정수(n)과 횟수(cnt)를 저장
- 두 가지 연산을 했을때 b보다 작거나 같을때만 queue에 저장하면서 반복
- b랑 같으면 종료 후 ans에 실행 횟수(cnt) 저장, 같지 않으면 ans의 초기값인  -1



## <03.28>

### 12907. [동물원](./gold5/boj_12907.py)

- 0부터 오름차순으로 순서대로 존재해야한다.
- 리스트에 저장했을 때, 1 또는 2여야 하고 3이면 존재하지 않으므로 res = 0
- 1이 나왔으면, 그 뒤에는 1보다 큰 수가 나올 수가 없다.
  - 1이 나오고 0이 나왔다면, 0보다 큰 수 또한 나올 수가 없다.
- 처음에는 dict를 이용하여 풀려고 했지만, 구현하는 것이 복잡해서 list로 변경

## <03.29>

### 16922. [로마 숫자 만들기](./silver3/boj_16922.py)

- BFS이용해서 풀이
- N번째에 set에 add해서 길이를 구했는데 처음에 시간초과가 발생했다.
- dfs안에 for문을 2개 사용했는데, 필요없는 for문이어서 제거했고, 더한 값도 바로바로 더하면서 dfs를 진행하여 시간초과를 해결하였다.

### 12871. [무한 문자열](./silver5/boj_12871.py)

- s, t에 각 문자열의 길이를 곱해서 같은 길이에서 같은지 비교했다.
- 길이가 매우 커지면 최소공배수까지만 만들어서 비교하는게 더 좋을것 같다.

### 12904. [A 와 B](./gold5/boj_12904.py)

- 처음엔 A -> B(16953)번처럼 풀었지만 시간초과 발생
- 작은거부터 시작해서 경우의 수가 너무 많기때문
- 큰거부터 시작해서 거꾸로 돌아가면서 같아지는지 확인했다.

## <03.31>

### 1242. [소풍](./gold2/boj_1242.py)

- 시작하는 위치 중심으로 k번째가
  - 동호의 번호와 같으면 종료
  - 작으면 동호의 번호 하나 감소
  - 한바퀴 돌면 끝나는 지점 = 시작지점으로 설정 후 끝날때까지  반복

### 17103. [골드바흐 파티션](./silver2/boj_17103.py)

- 에라토스테네스의 체 이용
- 소수 반복하면서 입력 값에서 소수 빼고 남은 수가 소수이면 ans + 1

## <04.03>

### 16973. [직사각형 탈출](./gold5/boj_16973.py)

- BFS사용
- 시간초과 발생 (나중에 다시 풀기)

## <04.09>

### 2178. [미로 탐색](./silver1/boj_2178.py)

- BFS

### 2206. [벽 부수고 이동하기](./gold4/boj_2206.py)

- DFS(recursion error)
- BFS
  - visited를 1차원으로 사용했을 경우
    - test_case는 통과했지만 오답
    - 앞에서 벽을 뚫고 왔을때와 뚫지 않고 왔을 때 거리가 같은 경우 문제가 발생한다.
      - 뚫었을 경우와 뚫지 않은 경우를 나눠서 2차원 배열생성해서 방문체크

## <04.10>

### 1697. [숨바꼭질](./silver1/boj_1697.py)

- BFS
- x-1, x+1, x*2 를 queue에 저장하면서 가는데 걸린 시간 visited에 체크 , 동생 찾으면 return
- queue를 만들 때 list 대신 deque를 생성하면 속도가 훨씬 빨라진다 (`from collections import deque`)
  - 시간복잡도 O(n) vs O(1) 차이

## 11866. [요세푸스0](./silver4/boj_11866.py)

- deque.rotate 사용해봄



## <04.24>

### 1753. [최단경로](./gold5/boj_1753.py)

- dijkstra
- 인접 행렬 사용하면 메모리초과 (1≤V≤20,000, 1≤E≤300,000)
- 시간초과 발생
  - 우선순위 큐 + sys.stdin.readline 사용하니 통과

## <04.25>

### 1920. [수 찾기](./silver4/boj_1920.py)

- 이진탐색 연습

### 1197. [최소 스패닝 트리](./gold4/boj_1197.py)

- MST 연습 (prim, kruskal)
- prim은 heapq 안쓰니까 시간초과 발생(최솟값 계속 구해서 그런듯?)



## <06.03>

### 1916. [최소비용 구하기](./gold5/boj_1916.py)

- 다익스트라 연습
- heapq 사용, input=sys.stdin.readline 안하면 시간초과
- 인접리스트 만들때 도시의 개수로 만들어야되는데 버스의 개수로 만들어서 계속 indexerror 발생



## <06.11>

### 2629. [양팔저울](./gold2/boj_2629.py)

> https://www.acmicpc.net/problem/2629

- DP문제
- `memo[level][weight]`
  - level 개를 사용했을때 weight 무게가 있는지 체크
- 확인하고자 하는 무게가 40000이하이므로, memo 범위 40001까지 설정
- +, 그대로, - 3가지 branch 진행하면서 memo
- 메모했거나 전부 사용했으면 return

## <06.22>

### 9663. [nQueen](./gold5/boj_9663.py)

### 1260. [DFS와 BFS](./silver2/boj_1260.py)

- 둘 다 PyPy3으로 제출하면 통과, Python3으로 하면 시간 초과

## <06.24>

### 2667. [단지번호붙이기](./silver1/boj_2667.py)

- dfs

## <06.28>

### 2637. [장난감조립](./gold2/boj_2637.py)

> https://www.acmicpc.net/problem/2637

- 위상정렬
- 진입 차수가 0인거부터 시작
- 연결된 부분들 계산하면서 간선 제거
- 차수가 0이 되면 큐에 추가해서 반복

## <07.03>

### 11659. [구간합구하기4](./silver3/boj_11659.py)

## <07.06>

### 14466. [소가 길을 건너간 이유 6](./gold4/boj_14466.py)

> https://www.acmicpc.net/problem/14466

## <07.07>

### 3273. [두 수의 합](./silver3/boj_3273.py)

### 2003. [수들의 합2](./silver3/boj_2003.py)

- 투 포인터 사용

## <07.08>

### 1062. [가르침](./gold4/boj_1062.py)

> https://www.acmicpc.net/problem/1062

> 비트마스킹 사용

>  처음에 60%쯤에서 오답이 나왔다.
>
> ※반례
>
> 2 15
> antabtica
> antatica
>
> ans = 2 나와야 하는데 0이 나왔다. => 전체 단어의 수(len(all_words)보다 k가 크면 n 출력

## <07.09>

### 15686. [치킨 배달](./gold5/boj_15686.py)

>https://www.acmicpc.net/problem/15686

처음에 bfs로 접근해서 시간이 엄청 오래걸렸다.

가정집, 치킨집 좌표를 저장해두고 완전 탐색하며 최소 거리를 계산하면 훨씬 간단해진다.



## <07.10>

### 16234. [인구 이동](./gold5/boj_16234.py)

> PyPy3 으로 pass
>
> 4 1 9
> 96 93 74 30
> 60 90 65 96
> 5 27 17 98
> 10 41 46 20
>
> ans = 1

처음에 방문표시 따로, 인구수 계산 따로 해서 시간초과 발생

visited 표시를 할 때 이동 못하는 부분이 방문처리 되어서 오류 발생

chk = False이면 visited를 0으로 초기화시켜줘서 해결

## <07.12>

### 15591. [MooTube(Silver)](./gold5/boj_15591.py)

- bfs로 연결 가능한 노드 탐색
- 문제의 설명이 복잡해서 처음에 문제 이해하는게 어려웠다.
  - 농부의 질문 Q마다 v노드에서 인접한 가중치가 k이하인 노드들을 탐색하며 더하는 문제

## <07.20>

### 4485. [녹색 옷 입은 애가 젤다지?](./gold4/boj_4485.py)

- 처음에 왼쪽 오른쪽 DP를 이용해서 풀려고 했는데 실패

```markdown
3 7 2 0 1
2 8 0 9 1
1 2 1 8 1
9 8 9 2 0
3 6 5 1 5
예제 2번의 경우 3-2-1-2-1-0-2-0-1-1-1-0-5 = 19로 아래로 갔다가 위로 올라가야 하는 경우가 있다.
```

- 다익스트라 사용
  - heapq로 최소거리부터 탐색, n-1,n-1까지 가면 종료

## <07.21>

### 22251. [빌런호석](./gold5/boj_22251.py)

- 0부터 9까지 각각 0~9로 바꿀때의 변경 횟수 저장
- 1부터 n까지 돌면서 바꿀 수 있는지 비교
- 자리수 비교할 때 1의자리부터 비교해야 편함, 앞에서부터 비교 하려면 0 채워놓고 비교해야함

### 22252. [정보상인호석](./gold5/boj_22252.py)

- dict에 heapq 이용해서 push/pop

- 꺼낼 때 없는이름 for문 돌리고 if info.get(name) 계속 확인해서 시간초과 발생

  name 없는거 바로 continue하고,  들어있는 정보 갯수보다 원하는 갯수가 크면 들어있는 정보만큼만 돌렸더니 패스

## <07.22>

### 20055. [컨베이어 벨트 위의 로봇](./silver1/boj_20055.py)

- 문제를 잘 이해하고 1~4번을 따라하면 된다.
- 처음에 컨베이어 벨트의 내구도를 로봇의 내구도라고 생각해서 힘들었다.

## <07.23>

### 14888. [연산자 끼워넣기](./silver1/boj_14888.py)

## <07.24>

### 14499. [주사위 굴리기](./gold5/boj_14499.py)

- 주사위 굴릴때마다 동/서/남/북 구른 후의 모양 생각해서 1~6번 위치에 해당 위치 값으로 변경
- 주사위 맨 처음에 0으로 초기화 조건을 못봐서 헤맸다. (문제 조건 잘 읽기!)

## <07.25>

### 17144. [미세먼지 안녕!](./gold5/boj_17144.py)

- 미세먼지 확산 -> 공기청정기  순서로 주어진 시뮬레이션대로 구현

## <07.26>

### 1916. [최소비용 구하기](./gold5/boj_1916.py)

- 경로 같은데 비용이 다른 경우도 있을 수 있어서 `d[node] < weight` 인 경우 가지치기필요

### 16973. [직사각형 탈출](./gold5/boj_16973.py)

- 직사각형 x,y 전체 검사하면 시간초과
- 벽 위치들만 미리 저장해놓고 검사

## <07.27>

### 20442. [ㅋㅋ루ㅋㅋ](./gold3/boj_20442.py)

> 투 포인터

- lk[] = R의 왼쪽 K갯수, rk[] = R의 오른쪽 K갯수
- 문자를 지워서 새로운 문자열을 만들 수 있다.
- lk와 rk 중에서 작은 수만큼 K를 붙일 수 있다.
  - 양쪽에 붙일 수 있으므로 2배
  - `2 * min(lk([l], rk[r])`
- lk와 rk의 길이는 R의 갯수이다.
  - 연속된 R은 ㅋㅋ루ㅋㅋ 문자열이 된다.
  - `r - l + 1`

## <07.29>

### 12865. [평범한 배낭](./gold5/boj_12865.py)

> 0/1 *Knapsack* Problem

ABCD의 value와 weight가 있을 때,

A,B,C,D가 있는 경우 vs 없는경우로 나눠서 DP

`DP(n,w) = max(DP(n-1,w), DP(n-1, w-w[n]) + val[n])`

## <07.30>

### 2580. [스도쿠](./gold4/boj_2580.py)

> 빈칸에 들어갈 값들 채워보면서 백트래킹

## <07.31>

### 11003. [최솟값 찾기](./platinum5/boj_11003.py)

> 슬라이딩 윈도우 + deque

Di =  Ai부터 Ai바로 전 L개의 윈도우까지의 최솟값이다.

시간복잡도가 O(1)인 deque를 이용해서 (값, 인덱스) 번호인 (Ai, i)를 저장한다.

윈도우를 이동하면서 인덱스값이 윈도우를 벗어나면 윈도우에서 제거하고, 값이 넣는 값보다 더 크면 윈도우에서 제거한다.

그러면 항상 윈도우에서 최솟값이 제일 앞에 존재한다.

```markdown
윈도우 크기 : 3
1 5 2 3 6 2 3 7 3 5 2 6

(1), (1,5), (1,5,2) (5,2,3), (2,3,6), (3,6,2) ,(6,2,3) ... (5,2,6)의 최솟값이 D이다.
=> 1 1 1 2 2 2 2 2 3 3 2 2

3개씩 하나하나 비교해서 최솟값을 출력하면 시간초과 발생한다. => 슬라이딩 윈도우
가운데 겹치는 L-1개는 그대로 두고 앞에서 하나 제거, 뒤에서 하나 추가 => deque

윈도우가 커지면 윈도우 안에서 최솟값을 출력할 때도 비교해야한다.
=> 윈도우에 넣을 때 넣는 값보다 큰 값을 미리 제거해서 맨 앞의 값을 최솟값으로 만든다.
```

## <08.01>

### 1306. [달려라 홍준](./platinum5/boj_1306.py)

> 슬라이딩 윈도우

위의 최솟값 찾기 문제처럼 윈도우에 최댓값 저장하고 작은값 제거 + 윈도우 벗어나면 제거

광고판을 항상 2m-1개씩 봐야하므로, ans[2m-2:] join해서 출력

## <08.02>

### 21924. [도시 건설](./gold4/boj_21924.py)

> MST - Prim 알고리즘

임의의 점에서 시작해서 연결된 노드들 리스트에 삽입

heapq 최소힙 사용해서 작은 순서대로 정렬

- heapq 없이 최솟값 구했더니 시간초과발생

visited 처리하면서 모든 점을 방문하면 종료

모든 점 방문하지 못하고 while문 끝나면 -1 return

## <08.03>

### 10844. [쉬운 계단 수](./silver1/boj_10844.py)

> DP

0일때와 9일때는 각각 1, 8밖에 올 수 없고 1~8까지는 앞뒤로 2개의 수만큼 올 수 있다. 따라서 다음과 같은 식을 세울 수 있다.

```markdown
dp[i][j] = dp[i-1][j+1] (j=0)
dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1] (0<j<9)
dp[i][j] = dp[i-1][j-1] (j=9)

dp[i][j] => i번째 자리에 j가 올 수 있는 경우의 수
```

한자리수일땐 맨 앞에 0이 올 수 없으므로 `dp[1][0]=0` , 나머지는 1로 초기화한 후 올라가면서 계산하고 n번째 자리에 0~9가 오는 경우의 합을 구한다.

## <08.04>

### 5014. [스타트링크](./gold5/boj_5014.py)

> BFS

DFS로 접근하면 시간초과 발생 => BFS사용

## <08.05>

### 5430. [AC](./gold5/boj_5430.py)

> deque사용해서 뒤집었는지 여부에 따라서 pop / popleft로 앞이나 뒤에거 제거
>
> 계속 오답이 나왔었는데, 전체 리스트를 다 지우면 빈 문자열을 출력해야하고 빈 상태에서 한번 더 지워야 error를 출력하는것이다.

## <08.07>

### 1300. [K번째 수](./gold3/boj_1300.py)

> 이분탐색
>
> 전체 배열을 만들어서 1차원 배열로 옮기면 메모리 초과 발생

x보다  작거나 같은 수의 갯수 = min(x//i, N)

N = 3, x는 4이면

| i=1     | 1     | 2     | 3    | min(4, 3) = 3     |
| ------- | ----- | ----- | ---- | ----------------- |
| **i=2** | **2** | **4** | 6    | **min(2, 3) = 2** |
| **i=3** | **3** | 6     | 9    | **min(1, 3) = 1** |

4보다 작거나 같은 수의 갯수 cnt = 3 + 2 + 1 = 6이다.

cnt >= k가 되면, cnt보다 작거나 같은 수가 k개이므로 B[k]가 될 수 있다.

left = 1, right = k로 두고 시작해서,

k가 cnt보다 크면  더 큰 부분을 탐색해야 하므로 left = mid + 1

작거나 같으면, right = mid -1, ans = mid로 초기화 하면서 left = right가 될 때까지 계속 탐색한다.

```markdown
예제에서 N=3, K=7이므로

i) left = 1, right = 7, mid = 4

cnt = 6 < k이므로 left = 5

ii) left=5, right = 7, mid = 6

cnt = 8 > k 이므로 ans = 6, right = 5

iii) left = right =5 이므로 종료
```

## <08.08>

### 11053. [가장 긴 증가하는 부분수열](./silver2/boj_11053.py)

> 전체 수열 돌면서 앞의 값과 비교해서 dp 저장

### 12015. [가장 긴 증가하는 부분수열2](./gold2/boj_12015.py)

> bisect 이진탐색 사용
>
> bisect_left(a, x) = a에 x를 삽입할 인덱스 왼쪽값 리턴

```markdown
10 20 10 30 20 50
```

0. 초기값 [10] 넣어두고 시작

1. 20 입력 =>  [10 20], 10보다 크므로 끝에 20 추가
2. 10 입력 => [10 20] , 20보다 작으므로 10을 넣을 위치 탐색, ans[0] = min(10,10)값으로 변경
3. 30 입력 =>  [10 20 30], 20보다 크므로 끝에 30추가 
4. 20 입력 => [10 20 30], 30보다 작으므로 20넣을위치 탐색, ans[1]=min(20,20)으로 변경
5. 50 입력 => [10 20 30 50], 30보다 크므로 맨 끝에 삽입
6. len(ans) =  4

### 12738. [가장 긴 증가하는 부분수열3](./gold2/boj_12738.py)

> 2와 숫자의 범위만 바뀌었다. 코드는 동일

### 14002. [가장 긴 증가하는 부분수열4](./gold4/boj_14002.py)

> 11053번 DP 사용해서 구한 ans에서 거꾸로 내려오면서 저장

## <08.10>

### 2573. [빙산](./gold4/boj_2573.py)

> 빙산 있는 좌표 저장해서 시뮬레이션 실행 이후 BFS 사용해서 빙산 덩어리 체크

**만일 전부 다 녹을 때까지 두 덩어리 이상으로 분리되지 않으면 프로그램은 0을 출력한다.**

- 처음에 조건 하나 체크 못해서 56퍼에서 오답
- 전부 길이 체크해서 전부 0이면 0출력하고 바로 종료

## <08.12>

### 2661. [좋은 수열](./gold4/boj_2661.py)

> dfs로 돌면서 전부 확인

## <08.15>

### 1644. [소수의 연속합](./gold3/boj_1644.py)

> 에라토스테네스의 체 + 맨 처음부터 start, end 잡고 한칸씩 이동하면서 연속합이 되는지 체크

### 1747. [소수 & 팰린드롬](./gold5/boj_1747.py)

> 입력이 1 ~ 1000000 이지만 출력은 1000000보다 클 수 있다
>
> 1000000일때 1003001이 나오므로 MAX_SIZE = 1003001로 잡고 에라토스테네스의 체를 구한다.

## <08.16>

### 14891. [톱니바퀴](./gold5/boj_14891.py)

> deque.rotate 사용
>
> 하나씩 돌면서 시계/반시계 확인하는 줄 알았는데 초기위치로 비교해서 도는 방식이었다.

## <08.18>

### 2606. [바이러스](./silver3/boj_2606.py)

> 단순 BFS

## <08.19>

### 9205. [맥주 마시면서 걸어가기](./silver1/boj_9205.py)

> BFS
>
> 방문한 좌표를 dict에 저장해서 방문했는지 체크해서 목적지까지 이동할 수 있는지 체크

## <08.20>

### 2644. [촌수계산](./silver2/boj_2644.py)

> BFS

## <08.21>

### 2468. [안전 영역](./silver1/boj_2468.py)

> BFS + 완전탐색

## <08.22>

### 7569. [토마토](./silver1/boj_7569.py)

> BFS + deque 사용

익은 토마토 좌표를 저장해놓고 deque에서 꺼내면서 상하좌우앞뒤 6방향의 토마토를 1로 만들고 deque에 저장하면서 인접한 칸을 바꿀 수 없을때까지 진행

최종적으로 안익은 토마토(0)가 있는지 체크해서 있으면 -1, 없으면 ans

## <08.30>

### 13458. [시험감독](./bronze/boj_13458.py)

- 단순 계산

## <08.31>

### 3190. [뱀](./gold5/boj_3190.py)

- deque를 이용해서 규칙대로 사과 유무에 따라 이동, 제거 (꼬리 위치 저장용도)
- visited로 현재 뱀 위치 표시
- 벽에 부딪히거나, 몸에 부딪히면 종료
- **모든 방향 명령이 끝난 이후에는 벽이나 몸에 부딪힐때까지 마지막 방향으로 계속 이동한다.**

## <09.01>

### 14501. [퇴사](./silver4/boj_14501.py)

- 범위가 작아서 bfs로 계산하면 금방 풀린다.
- dp로도 풀이
  - `T_i`일 이후와 하루 뒤의 dp를 갱신하면서 계산
  - index error때문에 n번째 넘어가지 않게 조건을 걸거나 dp 배열을 크게 잡아야 한다. 
    - 여기서는 i + P_i <= n 조건을 걸어서 제한했다.

## <09.02>

### 1966. [프린터큐](./silver3/boj_1966.py)

- deque 이용

## <09.05>

### 20500. [Ezreal 여눈부터 가네 ㅈㅈ](./gold5/boj_20500.py)

- dfs로 하면 recursion error발생 (dp로 풀어야한다.)

- 15의 배수 = 3의배수 + 5의배수

  - `dp[i][j] `= i번째 자리일 때 j라는 나머지를 가진 수

- 5의 배수

  - `dp[1][1] = 1`

- 3의 배수

  - 모든 자리수의 합이 3으로 나눠지면 3의 배수

  - 1더하면 1%3 = 1 증가, 5더하면 5%3 = 2 증가

  - `dp[i][0] = dp[i-1][1] + dp[i-1][2]`

    `  dp[i][1] = dp[i-1][0] + dp[i-1][2]`

    `  dp[i][2] = dp[i-1][0] + dp[i-1][1]`

- `dp[n][0]` = n번째까지 놨을때 15로 나눠지는 수의 개수

## <09.11>

### 19951. [태상이의 훈련소 생활](./silver1/boj_19951.py)

- 누적합
- a부터 b까지 k를 더해서 작업해야 하는 높이를 저장해놓는다.
- b+1은 k를 빼준 이후 높이의 누적합을 계산해서 한번씩만 연산한다.
  - b+1에서 빼주면, a~b 까지는 k만큼 더해지고, b+1번째 부터는 다시 k를 빼주므로 누적합으로 작업해야 하는 높이의 계산이 가능해진다.

## <09.12>

### 11728. [배열 합치기](./silver5/boj_11728.py)

### 1965. [상자넣기](./silver2/boj_1965.py)

- DP

### 2138. [전구와 스위치](./silver2/boj_2138.py)

- 첫번째 스위치를 누르는 경우와 안누르는 경우 나눠서 생각
- 1번 스위치부터 n번 스위치까지 바로 앞 스위치의 값이 원하는 값이랑 같은지 확인 후 다르면 스위치를 누른다.
- 맨 앞의 전구부터 모두 확인했으므로 마지막까지 했을때 다르면 불가능한 경우이므로 -1을 출력한다.

## <09.14>

#### 12782. [비트 우정지수](./silver5/boj_12782.py)

- 자리별로 비교하면서 다르면서 1인 경우, 0인 경우 중 더 큰 값 계산

## <09.15>

#### 17069. [파이프 옮기기2](./gold5/boj_17069.py)

- DP를 파이프가 가로일때, 세로일때, 대각선일때 나눠서 생각
- 벽이 있는 경우 예외처리

## <09.16>

#### 16208. [귀찮음](./silver5/boj_16208.py)

- 정렬한 후 앞에서부터 작은거부터 곱하면서 계산하면 최솟값

## <09.17>

#### 16236. [아기 상어](./gold4/boj_16236.py)

- BFS를 이용한 시뮬레이션 문제
- 처음엔 bfs를 할 때, 먹을 수 있는 물고기가 없고, 크기가 같은 물고기가 있을때의 값을 반환해줘서 무한루프에 걸려 시간초과 오류가 발생했다.
- bfs를 하면 인접한 칸만 체크하므로
  - 먹을 수 있는게 있는지만 확인해서 있으면 가장 위, 가장 왼쪽 순서로 정렬을 통해 첫째 값을 반환하고,
  - eatable이 없으면 반복문을 종료하면 된다.
- 자기 몸집 크기만큼 먹으면 크기를 +1 해가면서 먹을 물고기가 없을때까지 반복

## <09.18>

#### 1937. [욕심쟁이 판다](./gold3/boj_1937.py)

> DFS + DP

- dfs 돌면서 dp를 저장하고 dfs 도중 저장된 값이 있으면 저장된 값 사용
- 전체 탐색하면서 최댓값 갱신 후 출력
  - dxy 순서에 따라 recurssion error가 발생했다.

#### 9375. [패션왕 신해빈](./silver3/boj_9375.py)

- dict로 의상 분류해서 갯수 체크
- 전체 경우의 수 계산 후 아무것도 안입는경우 -1

## <09.19>

#### 1931. [회의실 배정](./silver2/boj_1931.py)

- 끝나는 시간, 시작 시간 순서로 정렬
- n개를 돌면서 현재값을 끝나는 시간으로 갱신하면서 현재 시간보다 시작 시간이 크거나 같으면 cnt + 1 해서 갯수를 센다.
- sys.stdin.readline 없으면 5000ms, 사용하면 400ms로 크게 줄어들었다.

## <09.20>

#### 17129. [윌리암슨수액빨이딱따구리가 정보섬에 올라온 이유](./gold5/boj_17129.py)

- 단순 BFS문제

#### 5347. [LCM](./silver4/boj_5347.py)

- 유클리드 호제법 : GCD(A, B) = GCD(B, A%B)

- 최소공배수 = 두 수를 곱한 값을 최대공약수로 나눈다.

## <09.21>

#### 17141. [연구소 2](./gold5/boj_17141.py)

- 바이러스가 가능한 위치를 모두 저장한 다음 combination으로 m개를 뽑은 후 BFS
- 결과 중 최솟값 출력
- 아래와 같이 모두 1로 둘러싸여 있어서 바이러스가 퍼지지 못할 경우 0이 나와야 되는데 -1로 처리되서 오답이었다.

```
5 2
1 1 1 1 1
1 1 2 1 1
1 1 2 1 1
1 1 1 1 1
1 1 1 1 1
// 0
```

## <09.22>

#### 20159. [동작 그만, 밑장 빼기냐?](./gold5/boj_20159.py)

- 홀수번, 짝수번 부분합 계산
- 밑장 빼는 경우
  - 내 차례에 빼는경우 : 마지막 카드가 내꺼
  - 상대 차례에 빼는 경우 : 마지막 카드가 상대꺼
- 처음에 상대 차례에 빼는 경우를 생각하지 않아서 계속 오답이었다.

## <09.23>

#### 17484. [진우의 달 여행(Small)](./silver4/boj_17484.py)

- DFS

## <09.24>

#### 1780. [종이의 개수](./silver2/boj_1780.py)

- 모두 같은 종이가 아니면 재귀로 9분할 반복하면서 개수 체크

## <09.25>

#### 17265. [나의 인생에는 수학과 함께](./gold5/boj_17265.py)

- DFS
- 홀수,짝수번째 나눠서 문자열 더하거나, eval 사용해서 계산
- n-1, n-1에서 최대, 최소값 계산

## <09.26>

#### 2252. [줄 세우기](./gold2/boj_2252.py)

- 위상정렬

## <09.27>

#### 1516. [게임 개발](./gold3/boj_1516.py)

- 위상정렬
- 앞선 건물이 모두 지어진 후에 해당 건물을 지을 수 있다.
  - 앞선 건물 중 큰 값이 끝난 후에 해당 건물을 지을 수 있으므로 다음과 같은 식이 나온다.
  - `result[b] = max(result[b], result[now] + cost[b])`

#### 12100. [2048 (Easy)](./gold2/boj_12100.py)

- 시뮬레이션인데 생각해야 되는 것들이 많았다.
- 이동 횟수가 5번밖에 안되서 product를 사용해서 전체 조합 (0,0,0,0,0) ~ (3,3,3,3,3) 까지 만들고 완전탐색했다.
  - 여기서 가지치기하면 시간 줄일 수 있을 것같다.
- 스택 이용해서 같은 숫자 만나면 pop 해서 2배한 후 스택에 추가
- 숫자면 스택에 담고, 0이면 continue
- 이후 차례대로 넣어서 이동 완료
- 한 번 이동한 블록은 합쳐지면 안되도록 True / False 체크
- 한 번도 이동하지 못하는 경우에도 최댓값 계산해야 하므로, 모든 이동이 끝난 후 최댓값 계산 후 출력

## <09.28>

#### 2638. [치즈](./gold4/boj_2638.py)

- (0,0) 부터 bfs 돌면서 0인칸 -1로 변경, 공기와 인접한 치즈칸은 +1
- 치즈가 3이 될 때, 지울 칸에 저장
- 지울 칸 -1로 변경하면서 bfs 반복 후 전체 시간 체크

## <09.29>

#### 17396. [백도어](./gold5/boj_17396.py)

- 다익스트라

- 마지막 넥서스를 0으로 초기화
- 와드가 있는 곳은 그래프에 저장하지 않는다

## <09.30>

#### 4256. [트리](./gold4/boj_4256.py)

- preorder의 맨 앞의 값은 루트노드
- inorder에서 preorder의 값과 일치하는 부분에서 좌, 우로 나눠지는게 반복된다.
- 왼쪽, 오른쪽 순서로 dfs를 하면 마지막에 남는 값부터 출력하면 postorder

## <10.01>

#### 11049. [행렬 곱셈 순서](./gold3/boj_11049.py)

> DP문제

- n * n 행렬을 만들어서 start, end 까지의 곱의 최솟값을 저장한다.

- 2개씩 곱한것부터 n개씩 곱한것 순서로 계산해야 한다.
- start 부터 end까지 곱했을때 최솟값 = (start ~ k 번까지의 연산 수 + k+1부터 end까지의 연산 수 +첫번째 수 * k번째수 * 마지막수)
  - `dp[start][k] + dp[k+1][end] + arr[start][0] * arr[k][1] * arr[end][1]`

- index를 생각하는게 어려웠는데 다른 코드를 참고해서 3중 for문을 이용해서 구현했다.

## <10.02>

#### 2293. [동전 1](./silver1/boj_2293.py)

> DP

- coin을 작은것 부터 차례대로 넣을 수 있는 경우를 계산해준다.
  - coin과 같으면 1개 만들 수 있다.
    - `dp[coin] += 1`
  - 다르면, (i - coin)을 만들고 coin을 추가하는 횟수와 같다.
    - `dp[i] += dp[i-coin]`
- coin 입력이 작은것 부터 들어오지 않아서 sort를 해줘야 한다.
  - sort 없이 제출했더니 50%에서 오답이었다.

#### 14503. [로봇 청소기](./gold5/boj_14503.py)

- BFS
- 4방향에 1로 쌓여 있어서 index 체크 할 필요 없다.
- 조건대로 구현한 후에 청소한 칸 체크해서 출력하면 된다.

## <10.03>

#### 2294. [동전 2](./silver1/boj_2294.py)

> DP

- 동전 1과 비슷한 유형의 문제인데, k원을 만들 수 있는 동전의 최소 개수를 구하는 문제이다.
- dp를 처음에 최댓값으로 초기화 해준다. (동전 최대 가치가 100000이므로 100001로 설정)
- coin과 같은 가격이면 1개로 만들 수 있으므로 `dp[coin] = 1`
- coin + 1 부터 k + 1 까지 확인하면서 `dp[i] = min(dp[i], dp[i-coin] + 1)` 으로 갱신해준다.
  - 1 : i에 coin을 하나 추가
  - `dp[i-coin]` 앞에 저장된 i - coin 만드는데 사용된 값
    - coin만큼 추가했으므로 남은 금액은 (i - coin)
- 처음에 `min(dp[i] = min(dp[i], dp[i % coin] + i//coin))` 과 같이 coin 큰것 부터 넣으려고 했는데 28%에서 오답이 나왔다.
  - 큰걸 먼저 다 넣는다고 항상 최솟값을 보장하지는 않는다.

#### 1535. [안녕](./silver2/boj_1535.py)

> 배낭문제

- [12865. 평범한 배낭](#<07.29>)과 같은 문제
  - 배낭에 넣는다 = 인사를 한다
  - 배낭 최대 크기 = Life
  - 무게 = 기쁨

## <10.04>

#### 10971. [외판원 순회2](./silver2/boj_10971.py)

> DFS

- 일반적인 DFS에 마지막에 시작 위치로 돌아올 수 있는지 체크하면 된다.

#### 1091. [카드 섞기](./gold5/boj_1091.py)

- 핵심 내용
  - 플레이어는 **3명**으로 정해져 있다.
  - **처음 카드는 0, 1, 2, 3, ... n 까지 순서대로 정렬되어 있다.**
    - 이 부분의 설명이 부실한 것 같다.
  - S 는 셔플 규칙을 위한 리스트로 `cards[s[i]] = cards[i]`와 같은 규칙이다.
  - 셔플을 하면서 이전 값과 같은 값이 나오면 무한루프를 도는데, 맨 처음 리스트와 비교하면 된다. 
    - 바로 전의 값과만 비교해서 계속 시간초과가 발생했다.

#### 1003. [피보나치 함수](./silver3/boj_1003.py)

- DP
- 2차원 배열로 0일때, 1일때를 저장한다.
- `fib[0][0] = 1, fib[1][1] = 1` 로 시작
- 피보나치는 앞의 두 수를 더한만큼 호출되므로 다음과 같은 점화식 가능
  - `  fib[0][i] = fib[0][i-1] + fib[0][i-2]`
  - `  fib[1][i] = fib[1][i-1] + fib[1][i-2]`

#### 10451. [순열 사이클](./silver2/boj_10451.cpp)

- c++ 연습
- dfs로 방문 처리하면서 dfs 시작할 수 있는 곳 체크
- 다음 줄 추가해주면 in/out 빨라짐 => [관련내용](https://jaimemin.tistory.com/1521)
- 개행할 때 <<endl 보다 <<'\n' 이 더 빠름

```c++
int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);
}
```

#### 11724. [연결 요소의 개수](./silver2/boj_11724.cpp)

- c++연습

- DFS, BFS

- BFS의 경우 인접한 노드만 확인하지 않으면 1000번을 계속 확인하기 때문에 시간초과 발생

  - 따라서 벡터 사용해서 인접한 노드만 저장

- `vector<int> adj[1001];`

  - `[[],[], [], [], [] ... []]` 
    - python의 `adj = [[] for _ in range(1001)]` 과 같다.
  - `adj[i].push_back[j]` 으로 adj[i]에 j 추가 가능
    - python의 `adj[i].append(j)`과 같다.

- 간선이 0개거나 최댓값인 경우는 간선 연결상태 볼 필요 없이 0과 1이 된다.

- 10451번과 마찬가지로 bfs, dfs 시작한 횟수 출력

## <10.05>

#### 14889. [스타트와 링크](./silver3/boj_14889.cpp)

- c++
- n명중에 2/n명을 뽑은 다음 각 팀의 점수를 계산해서 최솟값을 갱신한다.
- 처음에 모든 `arr[i][j]`의 합을 저장해놓고 한 팀의 점수만 계산 후 빼려고 했는데, 이렇게 하면 1,2 // 3,4 가 팀이라면, 1,3 / 1,4 와 같은 필요없는 값들까지 들어있기 때문에 제대로 된 값 계산이 불가능

## <10.07>

#### 1817. [짐 챙기는 숌](./silver4/boj_1817.py)

- 입력 들어온 순서대로 넣어주는 문제
- 문제를 제대로 이해못해서 무거운 순서부터 넣어서 계속 틀렸다.

## <10.08>

#### 2812. [크게 만들기](./gold5/boj_2812.py)

- 가장 큰 값이 되려면 맨 앞의 자리수가 커야한다.
- stack에 저장하면서 num의 맨 앞에 있는 값이 stack의 마지막 값보다 더 커질 수 있는지 체크하고 더 크면 pop을 반복한다.
- pop해서 제거한 횟수를 체크해서 k개 이상으로 지우는 경우 방지
- 스택에 n-k개 넣기 전에 종료될 수 있으므로 while문이 끝난 이후 stack과 num을 더해서 출력해준다.

## <10.09>

#### 9251. [LCS](./gold5/boj_9251.py)

- DP
  - `dp[i][j] = a[i]까지랑 b[j]까지의 최대 길이`
- `dp[i+1][j+1]`
  - 같으면 `dp[i + 1][j + 1] = dp[i][j] + 1`
    - 같으면 이전까지 최대 공통길이에 1을 더해준다.
  - 다르면 `dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1])`
    - 다르면, a[i+1]까지와 b[j+1]까지의 최대 길이 중 더 큰 값 저장 (이전까지의 최대길이를 저장해야하기 때문)

#### 18110. [solved.ac](./silver4/boj_18110.py)

- 파이썬의 round는 홀수와 짝수일때 반올림이 다르기 때문에 round 새로 정의해서 사용

```python
print(round(2.5)) # 2
print(round(3.5)) # 4
```

- 0일때는 0 출력 (Zero Division 방지)

