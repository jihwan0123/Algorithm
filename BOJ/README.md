## <03.06>

### 2447. [별찍기 -10](./silver1/boj_2447.py)

- 머리로는 공백을 찍거나 별을 찍는게 생각이 되는데 구현이 되지 않았다.

- 1 2 3

- 4 5 6

- 7 8 9

- 위와 같이 3*3이 있을때, 5번만 공백이고 나머지는 *

- 이러한 구조를 하나로 봐서 1 ~ 9 까지 들어가는 식으로 반복된다.

-  별을 채워놓은 상태에서 공백을 찍고싶었는데 생각대로 되지 않아서 하나씩 돌면서 별을 찍는 방식으로 코드를 작성하였다.

  - 전체를 다 돌면서 별을 찍어서 시간이 오래걸리는것 같다.



- 💡 다음과 같이 zip 과 join 을 이용하면 간단하게 구현할 수 있다.

  - 파이썬의 장점을 이용하자!

  ```python
  def concatenate(r1, r2):
      return [''.join(x) for x in zip(r1, r2, r1)]
  ```

  



### 7562. [나이트의 이동](./silver2/boj_7562.py)

- BFS를 구현하는 방법에 대해 복습할 수 있었다.
- 시간을 줄이는 방법에 대해 더 생각해봐야 할듯하다.



## <03.27>

### 11399. [ATM](./silver3/boj_11399.py)

- 오름차순으로 정렬 후 더하기



### 16953. [A -> B](./silver1/boj_16953.py)

- queue 이용
- queue에 현재 정수(n)과 횟수(cnt)를 저장
- 두 가지 연산을 했을때 b보다 작거나 같을때만 queue에 저장하면서 반복
- b랑 같으면 종료 후 ans에 실행 횟수(cnt) 저장, 같지 않으면 ans의 초기값인  -1



## <03.28>

### 12907. [동물원](./gold5/boj_12907.py)

- 0부터 오름차순으로 순서대로 존재해야한다.
- 리스트에 저장했을 때, 1 또는 2여야 하고 3이면 존재하지 않으므로 res = 0
- 1이 나왔으면, 그 뒤에는 1보다 큰 수가 나올 수가 없다.
  - 1이 나오고 0이 나왔다면, 0보다 큰 수 또한 나올 수가 없다.
- 처음에는 dict를 이용하여 풀려고 했지만, 구현하는 것이 복잡해서 list로 변경

## <03.29>

### 16922. [로마 숫자 만들기](./silver3/boj_16922.py)

- BFS이용해서 풀이
- N번째에 set에 add해서 길이를 구했는데 처음에 시간초과가 발생했다.
- dfs안에 for문을 2개 사용했는데, 필요없는 for문이어서 제거했고, 더한 값도 바로바로 더하면서 dfs를 진행하여 시간초과를 해결하였다.

### 12871. [무한 문자열](./silver5/boj_12871.py)

- s, t에 각 문자열의 길이를 곱해서 같은 길이에서 같은지 비교했다.
- 길이가 매우 커지면 최소공배수까지만 만들어서 비교하는게 더 좋을것 같다.

### 12904. [A 와 B](./gold5/boj_12904.py)

- 처음엔 A -> B(16953)번처럼 풀었지만 시간초과 발생
- 작은거부터 시작해서 경우의 수가 너무 많기때문
- 큰거부터 시작해서 거꾸로 돌아가면서 같아지는지 확인했다.

## <03.31>

### 1242. [소풍](./gold2/boj_1242.py)

- 시작하는 위치 중심으로 k번째가
  - 동호의 번호와 같으면 종료
  - 작으면 동호의 번호 하나 감소
  - 한바퀴 돌면 끝나는 지점 = 시작지점으로 설정 후 끝날때까지  반복

### 17103. [골드바흐 파티션](./silver2/boj_17103.py)

- 에라토스테네스의 체 이용
- 소수 반복하면서 입력 값에서 소수 빼고 남은 수가 소수이면 ans + 1

## <04.03>

### 16973. [직사각형 탈출](./gold5/boj_16973.py)

- BFS사용
- 시간초과 발생 (나중에 다시 풀기)

## <04.09>

### 2178. [미로 탐색](./silver1/boj_2178.py)

- BFS

### 2206. [벽 부수고 이동하기](./gold4/boj_2206.py)

- DFS(recursion error)
- BFS
  - visited를 1차원으로 사용했을 경우
    - test_case는 통과했지만 오답
    - 앞에서 벽을 뚫고 왔을때와 뚫지 않고 왔을 때 거리가 같은 경우 문제가 발생한다.
      - 뚫었을 경우와 뚫지 않은 경우를 나눠서 2차원 배열생성해서 방문체크

## <04.10>

### 1697. [숨바꼭질](./silver1/boj_1697.py)

- BFS
- x-1, x+1, x*2 를 queue에 저장하면서 가는데 걸린 시간 visited에 체크 , 동생 찾으면 return
- queue를 만들 때 list 대신 deque를 생성하면 속도가 훨씬 빨라진다 (`from collections import deque`)
  - 시간복잡도 O(n) vs O(1) 차이

## 11866. [요세푸스0](./silver4/boj_11866.py)

- deque.rotate 사용해봄



## <04.24>

### 1753. [최단경로](./gold5/boj_1753.py)

- dijkstra
- 인접 행렬 사용하면 메모리초과 (1≤V≤20,000, 1≤E≤300,000)
- 시간초과 발생
  - 우선순위 큐 + sys.stdin.readline 사용하니 통과

## <04.25>

### 1920. [수 찾기](./silver4/boj_1920.py)

- 이진탐색 연습

### 1197. [최소 스패닝 트리](./gold4/boj_1197.py)

- MST 연습 (prim, kruskal)
- prim은 heapq 안쓰니까 시간초과 발생(최솟값 계속 구해서 그런듯?)



## <06.03>

### 1916. [최소비용 구하기](./gold5/boj_1916.py)

- 다익스트라 연습
- heapq 사용, input=sys.stdin.readline 안하면 시간초과
- 인접리스트 만들때 도시의 개수로 만들어야되는데 버스의 개수로 만들어서 계속 indexerror 발생



## <06.11>

### 2629. [양팔저울](./gold2/boj_2629.py)

> https://www.acmicpc.net/problem/2629

- DP문제
- `memo[level][weight]`
  - level 개를 사용했을때 weight 무게가 있는지 체크
- 확인하고자 하는 무게가 40000이하이므로, memo 범위 40001까지 설정
- +, 그대로, - 3가지 branch 진행하면서 memo
- 메모했거나 전부 사용했으면 return

## <06.22>

### 9663. [nQueen](./gold5/boj_9663.py)

### 1260. [DFS와 BFS](./silver2/boj_1260.py)

- 둘 다 PyPy3으로 제출하면 통과, Python3으로 하면 시간 초과

## <06.24>

### 2667. [단지번호붙이기](./silver1/boj_2667.py)

- dfs

## <06.28>

### 2637. [장난감조립](./gold2/boj_2637.py)

> https://www.acmicpc.net/problem/2637

- 위상정렬
- 진입 차수가 0인거부터 시작
- 연결된 부분들 계산하면서 간선 제거
- 차수가 0이 되면 큐에 추가해서 반복

## <07.03>

### 11659. [구간합구하기4](./silver3/boj_11659.py)

## <07.06>

### 14466. [소가 길을 건너간 이유 6](./gold4/boj_14466.py)

> https://www.acmicpc.net/problem/14466

## <07.07>

### 3273. [두 수의 합](./silver3/boj_3273.py)

### 2003. [수들의 합2](./silver3/boj_2003.py)

- 투 포인터 사용

## <07.08>

### 1062. [가르침](./gold4/boj_1062.py)

> https://www.acmicpc.net/problem/1062

> 비트마스킹 사용

>  처음에 60%쯤에서 오답이 나왔다.
>
> ※반례
>
> 2 15
> antabtica
> antatica
>
> ans = 2 나와야 하는데 0이 나왔다. => 전체 단어의 수(len(all_words)보다 k가 크면 n 출력

## <07.09>

### 15686. [치킨 배달](./gold5/boj_15686.py)

>https://www.acmicpc.net/problem/15686

처음에 bfs로 접근해서 시간이 엄청 오래걸렸다.

가정집, 치킨집 좌표를 저장해두고 완전 탐색하며 최소 거리를 계산하면 훨씬 간단해진다.



## <07.10>

### 16234. [인구 이동](./gold5/boj_16234.py)

> PyPy3 으로 pass
>
> 4 1 9
> 96 93 74 30
> 60 90 65 96
> 5 27 17 98
> 10 41 46 20
>
> ans = 1

처음에 방문표시 따로, 인구수 계산 따로 해서 시간초과 발생

visited 표시를 할 때 이동 못하는 부분이 방문처리 되어서 오류 발생

chk = False이면 visited를 0으로 초기화시켜줘서 해결

## <07.12>

### 15591. [MooTube(Silver)](./gold5/boj_15591.py)

- bfs로 연결 가능한 노드 탐색
- 문제의 설명이 복잡해서 처음에 문제 이해하는게 어려웠다.
  - 농부의 질문 Q마다 v노드에서 인접한 가중치가 k이하인 노드들을 탐색하며 더하는 문제

