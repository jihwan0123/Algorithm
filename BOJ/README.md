## <03.06>

### 2447. [별찍기 -10](./silver1/boj_2447.py)

- 머리로는 공백을 찍거나 별을 찍는게 생각이 되는데 구현이 되지 않았다.

- 1 2 3

- 4 5 6

- 7 8 9

- 위와 같이 3*3이 있을때, 5번만 공백이고 나머지는 *

- 이러한 구조를 하나로 봐서 1 ~ 9 까지 들어가는 식으로 반복된다.

-  별을 채워놓은 상태에서 공백을 찍고싶었는데 생각대로 되지 않아서 하나씩 돌면서 별을 찍는 방식으로 코드를 작성하였다.

  - 전체를 다 돌면서 별을 찍어서 시간이 오래걸리는것 같다.



- 💡 다음과 같이 zip 과 join 을 이용하면 간단하게 구현할 수 있다.

  - 파이썬의 장점을 이용하자!

  ```python
  def concatenate(r1, r2):
      return [''.join(x) for x in zip(r1, r2, r1)]
  ```

  



### 7562. [나이트의 이동](./silver2/boj_7562.py)

- BFS를 구현하는 방법에 대해 복습할 수 있었다.
- 시간을 줄이는 방법에 대해 더 생각해봐야 할듯하다.



## <03.27>

### 11399. [ATM](./silver3/boj_11399.py)

- 오름차순으로 정렬 후 더하기



### 16953. [A -> B](./silver1/boj_16953.py)

- queue 이용
- queue에 현재 정수(n)과 횟수(cnt)를 저장
- 두 가지 연산을 했을때 b보다 작거나 같을때만 queue에 저장하면서 반복
- b랑 같으면 종료 후 ans에 실행 횟수(cnt) 저장, 같지 않으면 ans의 초기값인  -1



## <03.28>

### 12907. [동물원](./gold5/boj_12907.py)

- 0부터 오름차순으로 순서대로 존재해야한다.
- 리스트에 저장했을 때, 1 또는 2여야 하고 3이면 존재하지 않으므로 res = 0
- 1이 나왔으면, 그 뒤에는 1보다 큰 수가 나올 수가 없다.
  - 1이 나오고 0이 나왔다면, 0보다 큰 수 또한 나올 수가 없다.
- 처음에는 dict를 이용하여 풀려고 했지만, 구현하는 것이 복잡해서 list로 변경

## <03.29>

### 16922. [로마 숫자 만들기](./silver3/boj_16922.py)

- BFS이용해서 풀이
- N번째에 set에 add해서 길이를 구했는데 처음에 시간초과가 발생했다.
- dfs안에 for문을 2개 사용했는데, 필요없는 for문이어서 제거했고, 더한 값도 바로바로 더하면서 dfs를 진행하여 시간초과를 해결하였다.

### 12871. [무한 문자열](./silver5/boj_12871.py)

- s, t에 각 문자열의 길이를 곱해서 같은 길이에서 같은지 비교했다.
- 길이가 매우 커지면 최소공배수까지만 만들어서 비교하는게 더 좋을것 같다.

### 12904. [A 와 B](./gold5/boj_12904.py)

- 처음엔 A -> B(16953)번처럼 풀었지만 시간초과 발생
- 작은거부터 시작해서 경우의 수가 너무 많기때문
- 큰거부터 시작해서 거꾸로 돌아가면서 같아지는지 확인했다.

## <03.31>

### 1242. [소풍](./gold2/boj_1242.py)

- 시작하는 위치 중심으로 k번째가
  - 동호의 번호와 같으면 종료
  - 작으면 동호의 번호 하나 감소
  - 한바퀴 돌면 끝나는 지점 = 시작지점으로 설정 후 끝날때까지  반복

### 17103. [골드바흐 파티션](./silver2/boj_17103.py)

- 에라토스테네스의 체 이용
- 소수 반복하면서 입력 값에서 소수 빼고 남은 수가 소수이면 ans + 1

## <04.03>

### 16973. [직사각형 탈출](./gold5/boj_16973.py)

- BFS사용
- 시간초과 발생 (나중에 다시 풀기)

## <04.09>

### 2178. [미로 탐색](./silver1/boj_2178.py)

- BFS

### 2206. [벽 부수고 이동하기](./gold4/boj_2206.py)

- DFS(recursion error)
- BFS
  - visited를 1차원으로 사용했을 경우
    - test_case는 통과했지만 오답
    - 앞에서 벽을 뚫고 왔을때와 뚫지 않고 왔을 때 거리가 같은 경우 문제가 발생한다.
      - 뚫었을 경우와 뚫지 않은 경우를 나눠서 2차원 배열생성해서 방문체크

## <04.10>

### 1697. [숨바꼭질](./silver1/boj_1697.py)

- BFS
- x-1, x+1, x*2 를 queue에 저장하면서 가는데 걸린 시간 visited에 체크 , 동생 찾으면 return
- queue를 만들 때 list 대신 deque를 생성하면 속도가 훨씬 빨라진다 (`from collections import deque`)
  - 시간복잡도 O(n) vs O(1) 차이

## 11866. [요세푸스0](./silver4/boj_11866.py)

- deque.rotate 사용해봄



## <04.24>

### 1753. [최단경로](./gold5/boj_1753.py)

- dijkstra
- 인접 행렬 사용하면 메모리초과 (1≤V≤20,000, 1≤E≤300,000)
- 시간초과 발생
  - 우선순위 큐 + sys.stdin.readline 사용하니 통과

## <04.25>

### 1920. [수 찾기](./silver4/boj_1920.py)

- 이진탐색 연습

### 1197. [최소 스패닝 트리](./gold4/boj_1197.py)

- MST 연습 (prim, kruskal)
- prim은 heapq 안쓰니까 시간초과 발생(최솟값 계속 구해서 그런듯?)



## <06.03>

### 1916. [최소비용 구하기](./gold5/boj_1916.py)

- 다익스트라 연습
- heapq 사용, input=sys.stdin.readline 안하면 시간초과
- 인접리스트 만들때 도시의 개수로 만들어야되는데 버스의 개수로 만들어서 계속 indexerror 발생



## <06.11>

### 2629. [양팔저울](./gold2/boj_2629.py)

> https://www.acmicpc.net/problem/2629

- DP문제
- `memo[level][weight]`
  - level 개를 사용했을때 weight 무게가 있는지 체크
- 확인하고자 하는 무게가 40000이하이므로, memo 범위 40001까지 설정
- +, 그대로, - 3가지 branch 진행하면서 memo
- 메모했거나 전부 사용했으면 return

## <06.22>

### 9663. [nQueen](./gold5/boj_9663.py)

### 1260. [DFS와 BFS](./silver2/boj_1260.py)

- 둘 다 PyPy3으로 제출하면 통과, Python3으로 하면 시간 초과

## <06.24>

### 2667. [단지번호붙이기](./silver1/boj_2667.py)

- dfs

## <06.28>

### 2637. [장난감조립](./gold2/boj_2637.py)

> https://www.acmicpc.net/problem/2637

- 위상정렬
- 진입 차수가 0인거부터 시작
- 연결된 부분들 계산하면서 간선 제거
- 차수가 0이 되면 큐에 추가해서 반복

## <07.03>

### 11659. [구간합구하기4](./silver3/boj_11659.py)

## <07.06>

### 14466. [소가 길을 건너간 이유 6](./gold4/boj_14466.py)

> https://www.acmicpc.net/problem/14466

## <07.07>

### 3273. [두 수의 합](./silver3/boj_3273.py)

### 2003. [수들의 합2](./silver3/boj_2003.py)

- 투 포인터 사용

## <07.08>

### 1062. [가르침](./gold4/boj_1062.py)

> https://www.acmicpc.net/problem/1062

> 비트마스킹 사용

>  처음에 60%쯤에서 오답이 나왔다.
>
> ※반례
>
> 2 15
> antabtica
> antatica
>
> ans = 2 나와야 하는데 0이 나왔다. => 전체 단어의 수(len(all_words)보다 k가 크면 n 출력

## <07.09>

### 15686. [치킨 배달](./gold5/boj_15686.py)

>https://www.acmicpc.net/problem/15686

처음에 bfs로 접근해서 시간이 엄청 오래걸렸다.

가정집, 치킨집 좌표를 저장해두고 완전 탐색하며 최소 거리를 계산하면 훨씬 간단해진다.



## <07.10>

### 16234. [인구 이동](./gold5/boj_16234.py)

> PyPy3 으로 pass
>
> 4 1 9
> 96 93 74 30
> 60 90 65 96
> 5 27 17 98
> 10 41 46 20
>
> ans = 1

처음에 방문표시 따로, 인구수 계산 따로 해서 시간초과 발생

visited 표시를 할 때 이동 못하는 부분이 방문처리 되어서 오류 발생

chk = False이면 visited를 0으로 초기화시켜줘서 해결

## <07.12>

### 15591. [MooTube(Silver)](./gold5/boj_15591.py)

- bfs로 연결 가능한 노드 탐색
- 문제의 설명이 복잡해서 처음에 문제 이해하는게 어려웠다.
  - 농부의 질문 Q마다 v노드에서 인접한 가중치가 k이하인 노드들을 탐색하며 더하는 문제

## <07.20>

### 4485. [녹색 옷 입은 애가 젤다지?](./gold4/boj_4485.py)

- 처음에 왼쪽 오른쪽 DP를 이용해서 풀려고 했는데 실패

```markdown
3 7 2 0 1
2 8 0 9 1
1 2 1 8 1
9 8 9 2 0
3 6 5 1 5
예제 2번의 경우 3-2-1-2-1-0-2-0-1-1-1-0-5 = 19로 아래로 갔다가 위로 올라가야 하는 경우가 있다.
```

- 다익스트라 사용
  - heapq로 최소거리부터 탐색, n-1,n-1까지 가면 종료

## <07.21>

### 22251. [빌런호석](./gold5/boj_22251.py)

- 0부터 9까지 각각 0~9로 바꿀때의 변경 횟수 저장
- 1부터 n까지 돌면서 바꿀 수 있는지 비교
- 자리수 비교할 때 1의자리부터 비교해야 편함, 앞에서부터 비교 하려면 0 채워놓고 비교해야함

### 22252. [정보상인호석](./gold5/boj_22252.py)

- dict에 heapq 이용해서 push/pop

- 꺼낼 때 없는이름 for문 돌리고 if info.get(name) 계속 확인해서 시간초과 발생

  name 없는거 바로 continue하고,  들어있는 정보 갯수보다 원하는 갯수가 크면 들어있는 정보만큼만 돌렸더니 패스

## <07.22>

### 20055. [컨베이어 벨트 위의 로봇](./silver1/boj_20055.py)

- 문제를 잘 이해하고 1~4번을 따라하면 된다.
- 처음에 컨베이어 벨트의 내구도를 로봇의 내구도라고 생각해서 힘들었다.

## <07.23>

### 14888. [연산자 끼워넣기](./silver1/boj_14888.py)

## <07.24>

### 14499. [주사위 굴리기](./gold5/boj_14499.py)

- 주사위 굴릴때마다 동/서/남/북 구른 후의 모양 생각해서 1~6번 위치에 해당 위치 값으로 변경
- 주사위 맨 처음에 0으로 초기화 조건을 못봐서 헤맸다. (문제 조건 잘 읽기!)

## <07.25>

### 17144. [미세먼지 안녕!](./gold5/boj_17144.py)

- 미세먼지 확산 -> 공기청정기  순서로 주어진 시뮬레이션대로 구현

## <07.26>

### 1916. [최소비용 구하기](./gold5/boj_1916.py)

- 경로 같은데 비용이 다른 경우도 있을 수 있어서 `d[node] < weight` 인 경우 가지치기필요

### 16973. [직사각형 탈출](./gold5/boj_16973.py)

- 직사각형 x,y 전체 검사하면 시간초과
- 벽 위치들만 미리 저장해놓고 검사

## <07.27>

### 20442. [ㅋㅋ루ㅋㅋ](./gold3/boj_20442.py)

> 투 포인터

- lk[] = R의 왼쪽 K갯수, rk[] = R의 오른쪽 K갯수
- 문자를 지워서 새로운 문자열을 만들 수 있다.
- lk와 rk 중에서 작은 수만큼 K를 붙일 수 있다.
  - 양쪽에 붙일 수 있으므로 2배
  - `2 * min(lk([l], rk[r])`
- lk와 rk의 길이는 R의 갯수이다.
  - 연속된 R은 ㅋㅋ루ㅋㅋ 문자열이 된다.
  - `r - l + 1`

## <07.29>

### 12865. [평범한 배낭](./gold5/boj_12865.py)

> 0/1 *Knapsack* Problem

ABCD의 value와 weight가 있을 때,

A,B,C,D가 있는 경우 vs 없는경우로 나눠서 DP

`DP(n,w) = max(DP(n-1,w), DP(n-1, w-w[n]) + val[n])`

## <07.30>

### 2580. [스도쿠](./gold4/boj_2580.py)

> 빈칸에 들어갈 값들 채워보면서 백트래킹

## <07.31>

### 11003. [최솟값 찾기](./platinum5/boj_11003.py)

> 슬라이딩 윈도우 + deque

Di =  Ai부터 Ai바로 전 L개의 윈도우까지의 최솟값이다.

시간복잡도가 O(1)인 deque를 이용해서 (값, 인덱스) 번호인 (Ai, i)를 저장한다.

윈도우를 이동하면서 인덱스값이 윈도우를 벗어나면 윈도우에서 제거하고, 값이 넣는 값보다 더 크면 윈도우에서 제거한다.

그러면 항상 윈도우에서 최솟값이 제일 앞에 존재한다.

```markdown
윈도우 크기 : 3
1 5 2 3 6 2 3 7 3 5 2 6

(1), (1,5), (1,5,2) (5,2,3), (2,3,6), (3,6,2) ,(6,2,3) ... (5,2,6)의 최솟값이 D이다.
=> 1 1 1 2 2 2 2 2 3 3 2 2

3개씩 하나하나 비교해서 최솟값을 출력하면 시간초과 발생한다. => 슬라이딩 윈도우
가운데 겹치는 L-1개는 그대로 두고 앞에서 하나 제거, 뒤에서 하나 추가 => deque

윈도우가 커지면 윈도우 안에서 최솟값을 출력할 때도 비교해야한다.
=> 윈도우에 넣을 때 넣는 값보다 큰 값을 미리 제거해서 맨 앞의 값을 최솟값으로 만든다.
```

## <08.01>

### 1306. [달려라 홍준](./platinum5/boj_1306.py)

> 슬라이딩 윈도우

위의 최솟값 찾기 문제처럼 윈도우에 최댓값 저장하고 작은값 제거 + 윈도우 벗어나면 제거

광고판을 항상 2m-1개씩 봐야하므로, ans[2m-2:] join해서 출력

## <08.02>

### 21924. [도시 건설](./gold4/boj_21924.py)

> MST - Prim 알고리즘

임의의 점에서 시작해서 연결된 노드들 리스트에 삽입

heapq 최소힙 사용해서 작은 순서대로 정렬

- heapq 없이 최솟값 구했더니 시간초과발생

visited 처리하면서 모든 점을 방문하면 종료

모든 점 방문하지 못하고 while문 끝나면 -1 return

## <08.03>

### 10844. [쉬운 계단 수](./silver1/boj_10844.py)

> DP

0일때와 9일때는 각각 1, 8밖에 올 수 없고 1~8까지는 앞뒤로 2개의 수만큼 올 수 있다. 따라서 다음과 같은 식을 세울 수 있다.

```markdown
dp[i][j] = dp[i-1][j+1] (j=0)
dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1] (0<j<9)
dp[i][j] = dp[i-1][j-1] (j=9)

dp[i][j] => i번째 자리에 j가 올 수 있는 경우의 수
```

한자리수일땐 맨 앞에 0이 올 수 없으므로 `dp[1][0]=0` , 나머지는 1로 초기화한 후 올라가면서 계산하고 n번째 자리에 0~9가 오는 경우의 합을 구한다.

## <08.04>

### 5014. [스타트링크](./gold5/boj_5014.py)

> BFS

DFS로 접근하면 시간초과 발생 => BFS사용

## <08.05>

### 5430. [AC](./gold5/boj_5430.py)

> deque사용해서 뒤집었는지 여부에 따라서 pop / popleft로 앞이나 뒤에거 제거
>
> 계속 오답이 나왔었는데, 전체 리스트를 다 지우면 빈 문자열을 출력해야하고 빈 상태에서 한번 더 지워야 error를 출력하는것이다.

## <08.07>

### 1300. [K번째 수](./gold3/boj_1300.py)

> 이분탐색
>
> 전체 배열을 만들어서 1차원 배열로 옮기면 메모리 초과 발생

x보다  작거나 같은 수의 갯수 = min(x//i, N)

N = 3, x는 4이면

| i=1     | 1     | 2     | 3    | min(4, 3) = 3     |
| ------- | ----- | ----- | ---- | ----------------- |
| **i=2** | **2** | **4** | 6    | **min(2, 3) = 2** |
| **i=3** | **3** | 6     | 9    | **min(1, 3) = 1** |

4보다 작거나 같은 수의 갯수 cnt = 3 + 2 + 1 = 6이다.

cnt >= k가 되면, cnt보다 작거나 같은 수가 k개이므로 B[k]가 될 수 있다.

left = 1, right = k로 두고 시작해서,

k가 cnt보다 크면  더 큰 부분을 탐색해야 하므로 left = mid + 1

작거나 같으면, right = mid -1, ans = mid로 초기화 하면서 left = right가 될 때까지 계속 탐색한다.

```markdown
예제에서 N=3, K=7이므로

i) left = 1, right = 7, mid = 4

cnt = 6 < k이므로 left = 5

ii) left=5, right = 7, mid = 6

cnt = 8 > k 이므로 ans = 6, right = 5

iii) left = right =5 이므로 종료
```

## <08.08>

### 11053. [가장 긴 증가하는 부분수열](./silver2/boj_11053.py)

> 전체 수열 돌면서 앞의 값과 비교해서 dp 저장

### 12015. [가장 긴 증가하는 부분수열2](./gold2/boj_12015.py)

> bisect 이진탐색 사용
>
> bisect_left(a, x) = a에 x를 삽입할 인덱스 왼쪽값 리턴

```markdown
10 20 10 30 20 50
```

0. 초기값 [10] 넣어두고 시작

1. 20 입력 =>  [10 20], 10보다 크므로 끝에 20 추가
2. 10 입력 => [10 20] , 20보다 작으므로 10을 넣을 위치 탐색, ans[0] = min(10,10)값으로 변경
3. 30 입력 =>  [10 20 30], 20보다 크므로 끝에 30추가 
4. 20 입력 => [10 20 30], 30보다 작으므로 20넣을위치 탐색, ans[1]=min(20,20)으로 변경
5. 50 입력 => [10 20 30 50], 30보다 크므로 맨 끝에 삽입
6. len(ans) =  4

### 12738. [가장 긴 증가하는 부분수열3](./gold2/boj_12738.py)

> 2와 숫자의 범위만 바뀌었다. 코드는 동일

### 14002. [가장 긴 증가하는 부분수열4](./gold4/boj_14002.py)

> 11053번 DP 사용해서 구한 ans에서 거꾸로 내려오면서 저장

## <08.10>

### 2573. [빙산](./gold4/boj_2573.py)

> 빙산 있는 좌표 저장해서 시뮬레이션 실행 이후 BFS 사용해서 빙산 덩어리 체크

**만일 전부 다 녹을 때까지 두 덩어리 이상으로 분리되지 않으면 프로그램은 0을 출력한다.**

- 처음에 조건 하나 체크 못해서 56퍼에서 오답
- 전부 길이 체크해서 전부 0이면 0출력하고 바로 종료

## <08.12>

### 2661. [좋은 수열](./gold4/boj_2661.py)

> dfs로 돌면서 전부 확인

## <08.15>

### 1644. [소수의 연속합](./gold3/boj_1644.py)

> 에라토스테네스의 체 + 맨 처음부터 start, end 잡고 한칸씩 이동하면서 연속합이 되는지 체크

### 1747. [소수 & 팰린드롬](./gold5/boj_1747.py)

> 입력이 1 ~ 1000000 이지만 출력은 1000000보다 클 수 있다
>
> 1000000일때 1003001이 나오므로 MAX_SIZE = 1003001로 잡고 에라토스테네스의 체를 구한다.

## <08.16>

### 14891. [톱니바퀴](./gold5/boj_14891.py)

> deque.rotate 사용
>
> 하나씩 돌면서 시계/반시계 확인하는 줄 알았는데 초기위치로 비교해서 도는 방식이었다.

## <08.18>

### 2606. [바이러스](./silver3/boj_2606.py)

> 단순 BFS

## <08.19>

### 9205. [맥주 마시면서 걸어가기](./silver1/boj_9205.py)

> BFS
>
> 방문한 좌표를 dict에 저장해서 방문했는지 체크해서 목적지까지 이동할 수 있는지 체크

## <08.20>

### 2644. [촌수계산](./silver2/boj_2644.py)

> BFS

## <08.21>

### 2468. [안전 영역](./silver1/boj_2468.py)

> BFS + 완전탐색

## <08.22>

### 7569. [토마토](./silver1/boj_7569.py)

> BFS + deque 사용

익은 토마토 좌표를 저장해놓고 deque에서 꺼내면서 상하좌우앞뒤 6방향의 토마토를 1로 만들고 deque에 저장하면서 인접한 칸을 바꿀 수 없을때까지 진행

최종적으로 안익은 토마토(0)가 있는지 체크해서 있으면 -1, 없으면 ans

## <08.30>

### 13458. [시험감독](./bronze/boj_13458.py)

- 단순 계산

## <08.31>

### 3190. [뱀](./gold5/boj_3190.py)

- deque를 이용해서 규칙대로 사과 유무에 따라 이동, 제거 (꼬리 위치 저장용도)
- visited로 현재 뱀 위치 표시
- 벽에 부딪히거나, 몸에 부딪히면 종료
- **모든 방향 명령이 끝난 이후에는 벽이나 몸에 부딪힐때까지 마지막 방향으로 계속 이동한다.**

## <09.01>

### 14501. [퇴사](./silver4/boj_14501.py)

- 범위가 작아서 bfs로 계산하면 금방 풀린다.
- dp로도 풀이
  - `T_i`일 이후와 하루 뒤의 dp를 갱신하면서 계산
  - index error때문에 n번째 넘어가지 않게 조건을 걸거나 dp 배열을 크게 잡아야 한다. 
    - 여기서는 i + P_i <= n 조건을 걸어서 제한했다.

## <09.02>

### 1966. [프린터큐](./silver3/boj_1966.py)

- deque 이용

## <09.05>

### 20500. [Ezreal 여눈부터 가네 ㅈㅈ](./gold5/boj_20500.py)

- dfs로 하면 recursion error발생 (dp로 풀어야한다.)

- 15의 배수 = 3의배수 + 5의배수

  - `dp[i][j] `= i번째 자리일 때 j라는 나머지를 가진 수

- 5의 배수

  - `dp[1][1] = 1`

- 3의 배수

  - 모든 자리수의 합이 3으로 나눠지면 3의 배수

  - 1더하면 1%3 = 1 증가, 5더하면 5%3 = 2 증가

  - `dp[i][0] = dp[i-1][1] + dp[i-1][2]`

    `  dp[i][1] = dp[i-1][0] + dp[i-1][2]`

    `  dp[i][2] = dp[i-1][0] + dp[i-1][1]`

- `dp[n][0]` = n번째까지 놨을때 15로 나눠지는 수의 개수

