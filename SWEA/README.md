# <02.05>

## 10202. [문자열 동화](./D5/swea_10202.py)

- n번째 자리까지 각각 비교 후 set으로 중복 체크해서 중복이 있으면 +1, 없으면 +2로 count



# <03.07>

## 10505. [소득 불균형](./D3/swea_10505.py)

- 평균 구해서 조건 만족하는 갯수 세는 간단한 문제



## 10580. [전봇대](./D3/swea_10580.py)

>  전선의 시작점과 끝점을 주고 교차점의 수를 구하는 문제

- 각 전선마다 완전탐색을 하며 교차점이 생기는 경우에 갯수를 셌다.
- 교차점마다 2번씩 세줬으므로 마지막에 2로 나누어 출력



# <03.08>

## 3233. [정삼각형 분할 놀이](./D3/swea_3233.py)

- a, b가 서로 배수의 관계로 주어진다.
- 위에부터 생각해보면 1,3,5,7,9 ...2*(a/b) -1 까지의 합이므로  a/b의 제곱을 하면 답이 나온다.

## 3260. [두 수의 덧셈](./D3/swea_3260.py)

- 파이썬은 그냥 더하면 된다.

## 3975. [승률 비교하기](./D3/swea_3975.py)

- 주어진대로 승률 비교하면 끝

## 4299. [태혁이의 사랑은 타이밍](./D3/swea_4299.py)

- 처음 시간 11일11시11분을 분단위로 구한 후,
- 입력 값을 분단위로 구해서 음수면 -1 아니면 두 값의 차를 출력한다.



# <03.09>

## 10804. [문자열의 거울상](./D3/swea_10804.py)

- 뒤에서부터 리스트 돌면서 각각 거울에 비친 모습 result list에 추가해서 출력

## 10726. [이진수 표현](./D3/swea_10726.py)

- 뒤에서 N번 만큼만 비교해서 2로 나눈 나머지가 모두 있으면 ON, 하나라도 아니면 OFF출력



# <03.10>

## 1244. [최대 상금](./D3/swea_1244.py)

- 처음엔 단순 삽입정렬인줄 알았지만 32888 -> 88832와 같은 식으로 결과가 나와야 하기 때문에 pass

- dfs를 이용해서 접근

  - 완전탐색을 하니 9,10번 test case에서 시간 초과 발생 (가지치기 필요!)

- dict를 이용해서 방문체크 (temp, cnt)

  ​	📝dict로 방문 체크하는 방법 기억해두기



# <03.13>

## 1949. [[모의 SW 역량테스트] 등산로 조성](./SW_test_sample/swea_1949.py)

- DFS를 이용해서 푸는 문제
- 먼저 `find_top` 함수를 만들어서 가장 높은 봉우리를 찾아서 `max_point` 라는 list에 저장
- dfs(i,j,c,s)
  - i, j : 좌표
  - c : 깎는 높이
  - s : 등산로 길이
- 가장 높은 지점부터 시작해서 dfs 시작 
  - 처음에 방문표시, 끝나고 방문표시 제거
  - 깎을수 있는 횟수가 남아있으면서 깎았을때 기존보다 낮아지면 방문
  - 등산로를 깎을 수 있으면 k 만큼 깎는 것이 아니라 두 지점의 차이 + 1만큼 깎아야 다음 등산로를 제대로 검사할 수 있다.
    - 처음에 두 지점의 차이에 abs를 붙이지 않아서 51개중 49개만 통과했었다.



# <03.14>

## 1952. [[모의 SW 역량테스트] 수영장](./SW_test_sample/swea_1952.py)

- 회원권의 종류 : 1일권, 1달권, 3달권, 1년권
- swim(m, price) 함수에서 m : 현재 월, price : m월 까지 지불 금액을 나타낸다.
- 1일권과 1달권의 경우 똑같이 m + 1 월로 넘어가므로, `min(month, plan[m - 1] * day)` 을 이용하여 한번에 처리하였다.

- m > 12일때 종료하면서 result 값과 비교하며 최솟값 계산해서 출력



## 4012. [[모의 SW 역량테스트] 요리사](./SW_test_sample/swea_4012.py)

- N개의 요리 중에서 N//2개의 요리를 선택하는 조합을 만든다.
- 선택한 조합과 나머지의 시너지의 합의 차가 최솟값일 때를 구한다.
-  if문에 넣기 좋게 visited를 방문하면 0, 안했으면 1로 설정했다.
- 처음에 조합 가지치기를 하지 않아서 시간초과가 발생하였다.

```python
    for i in range(k, N):
        if visited[i]:
            sel[idx] = i
            visited[i] = 0
            perm(idx + 1, i + 1)
            visited[i] = 1
```

- 다음과 같이 range를 0이 아닌 k부터 시작해서 가지치기를 해줘서 중복탐색을 하지 않고 시간초과가 발생하지 않을 수 있었다.

# <03.15>

## 1953. [[모의 SW 역량테스트] 탈주범 검거](./SW_test_sample/swea_1953.py)

- BFS를 이용해서 풀이
- 각 터널마다 
  - x, y가 전체 범위안에 들어가는지,
  - 각각의 터널이 연결되어 있는지,
  - 이미 방문하지 않았는지,
- 3가지를 확인한 뒤에 방문하지 않았으면 visited + 1 을 하고 queue에 저장해서 BFS
- 최종적으로 while문이 종료되었을 때,  총 visited 표시한 갯수를 셌다.
  - L = 1 인 경우가 test case에 있으므로 L = 1 일때 while문을 종료한다.



# <03.16>

## 4008. [[모의 SW 역량테스트] 숫자 만들기](./SW_test_sample/swea_4008.py)

 ```python
  calc = {0: (lambda a, b: a + b),
          1: (lambda a, b: a - b),
          2: (lambda a, b: a * b),
          3: (lambda a, b: int(a / b))
          }
 ```

- 다음과 같이 lambda 표현식을 이용해서 들어가는 순서대로  `+, -, x, / ` 연산식 계산하도록 만들었다.
- idx 값과 현재까지 계산의 총 합 `res`를 인자로 dfs를 돌려서 최댓값, 최솟값을 각각 `res_max`, `res_min` 에 넣는다.
- `dfs(0, nums[0])` 을 통해 최댓값 최솟값을 구해서 차를 출력한다.
  - 앞에서부터 계산하므로 초기값 = nums[0]

# <03.17>

## 1767. [[SW Test 샘플문제] 프로세서 연결하기](SW_test_sample/swea_1767.py)

- dfs로 풀어봤는데 index error가 발생했다.
- 나중에 다시 풀어봐야겠다.



# <03.18>

## 4371. [항구에 들어오는 배](./D3/swea_4371.py)

- 첫날에는 배가 무조건 존재
- 첫날 까지의 주기가 이미 존재하는 주기로 나눠떨어지면 중복되는 주기이다.
  - happy_day[i] - 1 이 period의 요소들로 나눠떨어지지 않으면 period에 더한다.
- 마지막으로 period의 길이를 구한다.



# <03.22>

## 3131. [100만 이하의 모든 소수](./D3/swea_3131.py)

- 에라토스테네스의 체
- 100만까지의 배열을 만들어 놓고 2부터 n까지 배수에 해당하는 수를 모두 지우고 남는 수를 출력



## 3142. [영준이와 신비한 뿔의 숲](./D3/swea_3142.py)

- 단순 방정식 문제



## 3143. [가장 빠른 문자열 타이핑](./D4/swea_3143.py)

- A 에서 B에 해당하는 문자열을 교체한 후 길이 계산



# <03.23>

## 9700. [USB 꽂기의 미스터리](./D3/swea_9700.py)

- 처음에 제대로 꽂냐 or 제대로 꽂지 못하냐 p * (1-q)  또는  (1-p)
- 이후로는 q 곱하면 정상적으로 꽂히는 확률

## 7675. [통역사 성경이](./D3/swea_7675.py)

- 처음에 replace 막 사용했더니 시간초과발생
- 전체 돌면서 `!,?,.` 만날때 검사
- 맨 앞 대문자 확인 후 뒷부분 slicing 사용해서 len = 1 인 경우 따로 처리해줘야 했다.



# <04.05>

## 11742. [트리의 전위순회](./D3/swea_11742.py)

## 1231. [중위순회](./D4/swea_1231.py)



# <04.06>

## 5174. [[파이썬 S/W 문제해결 기본] 8일차 - subtree](./D2/swea_5174.py)

## 5176. [[파이썬 S/W 문제해결 기본] 8일차 - 이진탐색](./D2/swea_5176.py)

## 5177. [[파이썬 S/W 문제해결 기본] 8일차 - 이진 힙](./D2/swea_5177.py)

## 5178. [[파이썬 S/W 문제해결 기본] 8일차 - 노드의 합](./D3/swea_5178.py)

## 1232. [[S/W 문제해결 기본] 9일차 - 사칙연산](./D4/swea_1232.py)



# <04.12>

## 1240. [[S/W 문제해결 응용] 1일차 - 단순 2진 암호코드](./D3/swea_1240.py)

- 암호는 56자리, 마지막 1을 기준으로 56개를 자른 후, 7개씩 끊어서 암호가 맞는지 확인
- 문제 이해하는게 어려웠다

## 1242. [[S/W 문제해결 응용] 1일차 - 암호코드 스캔](./D5/swea_1242.py)

- 암호의 길이가 7글자씩 끊어지지 않고 긴 암호와 짧은 암호가 같이 나와서 get_one_code 함수를 이용해서 암호가 맞는지 확인해줘야 했다.
- 암호가 0과 1의 비율로 이루어져 있기 때문에 0~9까지 password를 만들어 놓고, 리스트를 [::cnt]를 이용하여 쪼갠 후에 확인해야한다.



# <04.15>

## 5188. [[파이썬 S/W 문제해결 구현] 2일차 - 최소합](./D3/swea_5188.py)

## 5189. [[파이썬 S/W 문제해결 구현] 2일차 - 전자카트](./D3/swea_5189.py)

## 5201. [[파이썬 S/W 문제해결 구현] 3일차 - 컨테이너 운반](./D3/swea_5201.py)

## 5202. [[파이썬 S/W 문제해결 구현] 3일차 - 화물 도크](./D3/swea_5202.py)

## 5203. [[파이썬 S/W 문제해결 구현] 3일차 - 베이비진 게임](./D3/swea_5203.py)



# <04.16>

## 1486. [장훈이의 높은 선반](./D4/swea_1486.py)

## 1861. [정사각형 방](./D4/swea_1861.py)

## 2819. [격자판의 숫자 이어 붙이기](./D4/swea_2819.py)

## 4366. [정식이의 은행업무](./D4/swea_4366.py)

## 1970. [쉬운 거스름돈](./D2/swea_1970.py)



# <04.19>

## 5204. [병합정렬](./D3/swea_5204.py)

## 5205. [퀵 정렬](./D3/swea_5205.py)



# <04.20>

## 5207. [[파이썬 S/W 문제해결 구현] 4일차 - 이진 탐색](./D3/swea_5207.py)

## 5208. [[파이썬 S/W 문제해결 구현] 5일차 - 전기버스2](./D3/swea_5208.py)

## 5209. [[파이썬 S/W 문제해결 구현] 5일차 - 최소 생산 비용](./D3/swea_5209.py)

## 2806. [N-Queen](./D3/swea_2806.py)

- backtracking

## 1865. [동철이의 일 분배](./D4/swea_1865.py)

- 백트래킹으로 풀었는데 DP로 풀면 시간 단축 가능 - DP문제 풀어보기!

# <04.21>

## 5247. [[파이썬 S/W 문제해결 구현] 6일차 - 연산](./D4/swea_5247.py)

- bfs 사용했는데 queue를 사용해서 queue.pop(0)을 사용하면 시간초과 발생했다. collections import 해서 deque 사용하면 pass됨
  - queue.pop(0) 하면 시간복잡도O(n), deque의 popleft() 는 시간복잡도 O(1)

## 11942. [Dijkstra 적용](./D3/swea_11942.py)

- dict 이용해서 작성(list로 하는게 더 쉬울듯)

## 2814. [최장 경로](./D3/swea_2814.py)

- BFS이용

# <04.22>

## 5248. [[파이썬 S/W 문제해결 구현] 6일차 - 그룹 나누기](./D3/swea_5248.py)

- union find

## 5249. [[파이썬 S/W 문제해결 구현] 7일차 - 최소 신장 트리](./D4/swea_5249.py)

- MST

## 5250. [[파이썬 S/W 문제해결 구현] 7일차 - 최소 비용](./D3/swea_5250.py)

- bfs

## 5251. [[파이썬 S/W 문제해결 구현] 7일차 - 최소 이동 거리](./D4/swea_5251.py)

- dijkstra



# <04.23>

## 1249. [[S/W 문제해결 응용] 4일차 - 보급로](./D4/swea_1249.py)

- bfs

## 1251. [[S/W 문제해결 응용] 4일차 - 하나로](./D4/swea_1251.py)

- prim algorithm

## 7465. [창용마을 무리의 개수](./D4/swea_7465.py)

- union_find

## 1795. [인수의 생일 파티](./D6/swea_1795.py)

- 갈 때와 올 때의 인접행렬을 만들어서 dijkstra 알고리즘 2번 적용 후 합의 최댓값 출력