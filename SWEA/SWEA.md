# <03.07>

## 10505. 소득 불균형(D3)

- 평균 구해서 조건 만족하는 갯수 세는 간단한 문제



## 10580. 전봇대(D3)

>  전선의 시작점과 끝점을 주고 교차점의 수를 구하는 문제

- 각 전선마다 완전탐색을 하며 교차점이 생기는 경우에 갯수를 셌다.
- 교차점마다 2번씩 세줬으므로 마지막에 2로 나누어 출력

# <03.08>

## 3233. 정삼각형 분할 놀이(D3)

- a, b가 서로 배수의 관계로 주어진다.
- 위에부터 생각해보면 1,3,5,7,9 ...2*(a/b) -1 까지의 합이므로  a/b의 제곱을 하면 답이 나온다.

## 3260. 두 수의 덧셈(D3)

- 파이썬은 그냥 더하면 된다.

## 3975. 승률 비교하기(D3)

- 주어진대로 승률 비교하면 끝

## 4299. 태혁이의 사랑은 타이밍(D3)

- 처음 시간 11일11시11분을 분단위로 구한 후,
- 입력 값을 분단위로 구해서 음수면 -1 아니면 두 값의 차를 출력한다.

# <03.09>

## 10804. 문자열의 거울상(D3)

- 뒤에서부터 리스트 돌면서 각각 거울에 비친 모습 result list에 추가해서 출력

## 10726. 이진수 표현(D3)

- 뒤에서 N번 만큼만 비교해서 2로 나눈 나머지가 모두 있으면 ON, 하나라도 아니면 OFF출력

# <03.10>

## 1244. 최대 상금

- 처음엔 단순 삽입정렬인줄 알았지만 32888 -> 88832와 같은 식으로 결과가 나와야 하기 때문에 pass

- dfs를 이용해서 접근

  - 완전탐색을 하니 9,10번 test case에서 시간 초과 발생 (가지치기 필요!)

- dict를 이용해서 방문체크 (temp, cnt)

  ​	📝dict로 방문 체크하는 방법 기억해두기

# <03.13>

## 1949. [모의 SW 역량테스트] 등산로 조성

- DFS를 이용해서 푸는 문제
- 먼저 `find_top` 함수를 만들어서 가장 높은 봉우리를 찾아서 `max_point` 라는 list에 저장
- dfs(i,j,c,s)
  - i, j : 좌표
  - c : 깎는 높이
  - s : 등산로 길이
- 가장 높은 지점부터 시작해서 dfs 시작 
  - 처음에 방문표시, 끝나고 방문표시 제거
  - 깎을수 있는 횟수가 남아있으면서 깎았을때 기존보다 낮아지면 방문
  - 등산로를 깎을 수 있으면 k 만큼 깎는 것이 아니라 두 지점의 차이 + 1만큼 깎아야 다음 등산로를 제대로 검사할 수 있다.
    - 처음에 두 지점의 차이에 abs를 붙이지 않아서 51개중 49개만 통과했었다.

# <03.14>

## 1952. [모의 SW 역량테스트] 수영장

- 회원권의 종류 : 1일권, 1달권, 3달권, 1년권
- swim(m, price) 함수에서 m : 현재 월, price : m월 까지 지불 금액을 나타낸다.
- 1일권과 1달권의 경우 똑같이 m + 1 월로 넘어가므로, `min(month, plan[m - 1] * day)` 을 이용하여 한번에 처리하였다.

- m > 12일때 종료하면서 result 값과 비교하며 최솟값 계산해서 출력



## 4012. [모의 SW 역량테스트] 요리사

- N개의 요리 중에서 N//2개의 요리를 선택하는 조합을 만든다.
- 선택한 조합과 나머지의 시너지의 합의 차가 최솟값일 때를 구한다.
-  if문에 넣기 좋게 visited를 방문하면 0, 안했으면 1로 설정했다.
- 처음에 조합 가지치기를 하지 않아서 시간초과가 발생하였다.

```python
    for i in range(k, N):
        if visited[i]:
            sel[idx] = i
            visited[i] = 0
            perm(idx + 1, i + 1)
            visited[i] = 1
```

- 다음과 같이 range를 0이 아닌 k부터 시작해서 가지치기를 해줘서 중복탐색을 하지 않고 시간초과가 발생하지 않을 수 있었다.

# <03.15>

## 1953. [모의 SW 역량테스트] 탈주범 검거

- BFS를 이용해서 풀이
- 각 터널마다 
  - x, y가 전체 범위안에 들어가는지,
  - 각각의 터널이 연결되어 있는지,
  - 이미 방문하지 않았는지,
- 3가지를 확인한 뒤에 방문하지 않았으면 visited + 1 을 하고 queue에 저장해서 BFS
- 최종적으로 while문이 종료되었을 때,  총 visited 표시한 갯수를 셌다.
  - L = 1 인 경우가 test case에 있으므로 L = 1 일때 while문을 종료한다.

# <03.16>

## 4008. [모의 SW 역량테스트] 숫자 만들기

 ```python
  calc = {0: (lambda a, b: a + b),
          1: (lambda a, b: a - b),
          2: (lambda a, b: a * b),
          3: (lambda a, b: int(a / b))
          }
 ```

- 다음과 같이 lambda 표현식을 이용해서 들어가는 순서대로  `+, -, x, / ` 연산식 계산하도록 만들었다.
- idx 값과 현재까지 계산의 총 합 `res`를 인자로 dfs를 돌려서 최댓값, 최솟값을 각각 `res_max`, `res_min` 에 넣는다.
- `dfs(0, nums[0])` 을 통해 최댓값 최솟값을 구해서 차를 출력한다.
  - 앞에서부터 계산하므로 초기값 = nums[0]

# <03.17>

## [1767. [SW Test 샘플문제] 프로세서 연결하기](SW_test_sample/swea_1767.py)

- dfs로 풀어봤는데 index error가 발생했다.
- 나중에 다시 풀어봐야겠다.



# <03.18>

## 4371. 항구에 들어오는 배

- 첫날에는 배가 무조건 존재
- 첫날 까지의 주기가 이미 존재하는 주기로 나눠떨어지면 중복되는 주기이다.
  - happy_day[i] - 1 이 period의 요소들로 나눠떨어지지 않으면 period에 더한다.
- 마지막으로 period의 길이를 구한다.



# <03.22>

## 3131. 100만 이하의 모든 소수

- 에라토스테네스의 체
- 100만까지의 배열을 만들어 놓고 2부터 n까지 배수에 해당하는 수를 모두 지우고 남는 수를 출력



## 3142. 영준이와 신비한 뿔의 숲

- 단순 방정식 문제



## 3143. 가장 빠른 문자열 타이핑

- A 에서 B에 해당하는 문자열을 교체한 후 길이 계산

# <03.23>

## 9700. USB 꽂기의 미스터리

- 처음에 제대로 꽂냐 or 제대로 꽂지 못하냐 p * (1-q)  또는  (1-p)
- 이후로는 q 곱하면 정상적으로 꽂히는 확률

## 7675. 통역사 성경이

- 처음에 replace 막 사용했더니 시간초과발생
- 전체 돌면서 `!,?,.` 만날때 검사
- 맨 앞 대문자 확인 후 뒷부분 slicing 사용해서 len = 1 인 경우 따로 처리해줘야 했다.